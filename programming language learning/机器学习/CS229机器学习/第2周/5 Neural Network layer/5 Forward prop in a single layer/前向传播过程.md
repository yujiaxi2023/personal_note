![[Pasted image 20230517151843.png]]
对这个模型进行python的网络构建
```python
x = np.array([200., 17.])
```
![[Pasted image 20230517152008.png]]
现在 需要构建下面几个代码
```python
w1_1 = np.array([1, 2])
b1_1 = np.array([-1])
z1_1 = np.dot(w1_1,x) + b
a1_1 = sigmoid(z1_1)
```
这是完成一个单元的设计
接下来还有三个神经元需要同样的操作方式
![[Pasted image 20230517152338.png]]
```python
w1_2 = np.array([-3, 4])
b1_2 = np.array([-1])
z1_2 = np.dot(w1_2,x) + b
a1_2 = sigmoid(z1_2)
```
![[Pasted image 20230517152342.png]]
```python
w1_3 = np.array([5, -6])
b1_3 = np.array([2])
z1_3 = np.dot(w1_3,x) + b
a1_3 = sigmoid(z1_3)
```
将这三个数字作为一个数组变成第一层的输出
```python
a1 = np.array([a1_1, a1_2, a1_3])
```
![[Pasted image 20230517152455.png]]
第二层的计算式是如上图
```python
w2_1 = np.array([-7, 8])
b2_1 = np.array([3])
z2_1 = np.dot(w2_1,a1) + b2_1
a2_1 = sigmoid(z2_1)
```

![[Pasted image 20230517161759.png]]
有层网络的数值是如图所示
这里的a代表的是最开始的输入数值

```python
def dense(a_in, W, b, g):
	units = W.shape[1] # 代表有3个神经元
	a_out = np.zeros(units) # 将a初始化为0
	for j in range(units):
		w = W[:,j] # 代表从W中pull出第几列
		z = np.dot(w,a_in) + b[j]
		a_out[j] = g(z)
	return a_out
```
这就是一个单独的一层的运算逻辑
知道有多少个units也就是神经元
进行初始化
然后for循环每一个w参数单独计算
输出根据给定的g进行输出

接下来是整个神经网络的样子，这里是四层神经网络
```python
def sequential(x):
	a1 = dense(x, W1, b1)
	a2 = dense(a1, W2, b2)
	a3 = dense(a2, W3, b3)
	a4 = dense(a3, W4, b4)
	f_x = a4
	return f_x
```
W代表的是矩阵
w代表的是向量

