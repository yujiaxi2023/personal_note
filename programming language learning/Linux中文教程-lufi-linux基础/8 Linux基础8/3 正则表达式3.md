### + 重复1次到多次

```
grep -E '[0-9:]+' 5.txt
```
![[Pasted image 20231218205059.png]]

```
grep -Eo '[0-9:]+' 5.txt
```
![[Pasted image 20231218205154.png]]


### ? 重复0次到多次
```
grep -Eo '[0-9:]?' 5.txt
```
所以可以不包含这些东西
![[Pasted image 20231218205254.png]]

问号和星号一样的

还是取得ip的例子
```
grep -Eo '[0-9]{7,15}' secure|uniq -c
```
这里只要是符合数字,并且长度是7-15就可以被提取出来
实际上文本里面有数字的话也可以提取,这是不太准确的提取

IP地址我们拆成几组
```
[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}
```
这其实就是针对每一段正则一下,结果是比较准确的
```
grep -Eo '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' secure | uniq -c
```

![[Pasted image 20231218205650.png]]
但是我们写的值还是有问题,因为会有非法IP
999.999.999.999这种无效ip

```
(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)
```
这种是专业的正则
这个正则表达式是用来匹配 IP 地址的格式的。让我们来分解它：

- `(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)`:
  - 这一部分用来匹配 IP 地址中的每个段，可以是 0 到 255 之间的数字。
  - `25[0-5]` 匹配 250 到 255 之间的数字。
  - `2[0-4]\d` 匹配 200 到 249 之间的数字。
  - `[0-1]\d{2}` 匹配 100 到 199 之间的数字。
  - `[1-9]?\d` 匹配 0 到 99 之间的数字。

- `\.`:
  - 这是转义字符，用来匹配 IP 地址中的点号，IP 地址中的段是用点号分隔的。

将这四个段用点号连接起来，整个表达式就可以匹配标准的 IPv4 地址格式，如 `192.168.0.1`。


### grep -P 使用perl正则来提取内容
```
grep -Po "^(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)" ip.txt
```
perl正则比一般的默认使用的-E正则要强大一些
![[Pasted image 20231218211112.png]]

想要取得更准,正则就难写
