最简单的索引方式
**indexing**
```python
a = torch.rand(4,3,28,28)
a[0].shape
a[0,0].shape
a[0,0,2,4]
```
![[Pasted image 20230508181300.png]]
pytorch默认从dim0开始排序
![[Pasted image 20230508181358.png]]
代表是取第0张图片包含的就有4通道28x28像素
![[Pasted image 20230508181456.png]]
从第0个图片的第0个通道开始就有28x28个像素
![[Pasted image 20230508181539.png]]
这个代表的是第0张图第0通道的第二行第四列的像素值
这里返回来的是标量

**更高级的索引方式**
select first/last N 取前几张图片或者后几张图片
```python
a.shape
a[:2].shape
a[:2, :1, :, :].shape
a[:2, 1:, :, :].shape
a[:2, -1:, :, :].shape
```
跟python中切片是一样的
前取后不取
![[Pasted image 20230508182107.png]]
这里面-1开始从最后一个元素开始,就代表只取了最后一个通道
这里的1和:1对应的1时不一样的
前者时B 后者时灰度

select by steps 加了步长这个因素
```python
a[:,:,0:28:2,0:28:2].shape
a[:,:,::2,::2].shape
```
上面的代码就是步长是2
![[Pasted image 20230508182904.png]]

**选择具体的索引**
index_select()函数
第一个参数是对什么维度进行操作
第二个参数是直接进行索引
```python
a.shape
a.index_select(0, [0,2])
```
代码中就是取第0号维度上面的0和2号图片
结果就是第一个是2张图片,然后是3通道,28像素
![[Pasted image 20230508202208.png]]
下面是选择第1个维度
```python
a.index_select(1,[1,2])
```
这里就是取第一个维度也就是通道,通道中的1号和2号通道也就是RGB中的GB
其他的数据补全就行了
![[Pasted image 20230508202810.png]]
要注意不能直接给数值,需要变为tensor的形式才能索引到对应的index

```python
a.index_select(2, torch.arange(28)).shape
```
这就形成了一个 0-28的索引,所以对于这个维度刚好不变
![[Pasted image 20230508202821.png]]
```python
a.index_select(2, torch.arange(8)).shape
```
这里是对2号维度取了8个值
![[Pasted image 20230508202827.png]]

**代表任意多的维度**
...
```python
a.shape
a[...].shape
a[0,...].shape
a[:,1,...].shape
a[...,:2].shape
```
![[Pasted image 20230508203049.png]]
假如a是图中的size
...就代表了4个:
如果第一个维度0  后边是4个:
这样子写起来比   :,:,:  这样写方便很多
![[Pasted image 20230508203325.png]]

**利用掩码索引**
select by mask
.masked_selected()
```python
x = torch.randn(3,4)
mask = x.ge(0.5)
torch.masked_select(x, mask)
torch.masked_select(x, mask).shape
```
![[Pasted image 20230508203816.png]]
这种方式的缺点是会把tensor打平
![[Pasted image 20230508203859.png]]
这里的类型是bytetensor类型的数据
重新获得的tensor的size跟原来的tensor是完全无关的
![[Pasted image 20230508204003.png]]
dim=1不定长度的一个size 取决于有多少我们想要的数据

**数据打平后处理**
select by flatten index
```python
src = torch.tensor([[4, 3, 5],[6, 7, 8]])
torch.take(src, torch.tensor([0,2,5]))
```
take操作是先打平
下图是2行3列的变dim = 1 数值为6的tensor
![[Pasted image 20230508204404.png]]
然后取打平后的编码进行操作
torch.tensor后边表示从src张量中取0 2 5 为索引的元素, 返回到一个新的张量中