
- cat
- stack
- split
- chunk
split按长度拆分 chunk按照数量拆分

**cat**
- 统计成绩
有班级1-4的成绩单
有班级5-9的成绩单
```python
a = torch.rand(4,32,8)
b = torch.rand(5,32,8)
torch.cat([a,b],dim=0).shape
```
需要把这两个成绩单合在一起
第一个参数是一个list 包含我们要合并的tensor
第二个参数dim 是代表合并的维度
代码中的例子是
我们需要保证每个班级的人数是一样的,考的科目的数量是一定的
![[Pasted image 20230509161643.png]]
第一种是我们按照第0维度合并
图中可以看作有3个班级,每个班级有4个人 考了4门课程
从0维度加起来就是图中的 12 4

![[Pasted image 20230509161829.png]]
第二种是按照第1维度开始加
比如现在又2个成绩单的表 
第一个由4个学生考了4门 
第二个有这4个学生考了3门课程
最后的结果就是4个学生考了7门课程的成绩

需要保证的是cat的维度是可以不一样的,其他的维度是必须要一样 不然需要变成一样的维度

例子
```python
a1 = torch.rand(4,3,32,32)
a2 = torch.rand(5,3,32,32)

torch.cat([a1,a2],dim=0).shape

a2 = torch.rand(4,1,32,32)
torch.cat([a1,a2],dim=0).shape

torch.cat([a1,a2],dim=1).shape

a1 = torch.rand(4,3,16,32)
a1 = torch.rand(4,3,16,32)
torch.cat([a1,a2],dim=2).shape
```
![[Pasted image 20230509162442.png]]
首先创造两个tensor
先从0维度相加
![[Pasted image 20230509162542.png]]
然后将第二个tensor变为4 1 32 32  的size 对应不上shape就会报错
![[Pasted image 20230509162548.png]]
这个时候第二个tensor的0维度是匹配的,只有1维度不匹配
所以可以从dim1开始匹配
![[Pasted image 20230509162647.png]]
注释**实际需求可能是添加了一个图像通道**
![[Pasted image 20230509162737.png]]
这里的代码实际上可以看作时照片从横向变为上下两部分
然后加和到一起重新变为一张完整的照片

**stack**
stack会创建一个新的维度
```python
torch.cat([a1,a2],dim=2).shape
torch.stack([a1,a2],dim=2).shape
```
我们可以看到cat和stack的区别
![[Pasted image 20230509163034.png]]
这样就可以看出,这里的stack合并是把上下部分重新提取出来一个类称为上下
然后从第2维度这里使用idx 0 就是提取上半部分 idx 1就是提取下半部分

```python
a = torch.rand(32,8)
b = torch.rand(32,8)
torch.stack([a,b],dim=0).shape
```
![[Pasted image 20230509163305.png]]
这个代码表现了为什么使用stack而不使用cat
假设现在有2个班级为32个人 考了8门课
现在需要统计合在一起,但是需要分别出两个班级
如果使用cat函数,就变成了一个班64 个人
此时使用stack 函数就可以说有2个班级 每个班级32人

**下面是一些错误可能情况**
```python
a.shape
b = torch.rand([30,8])
torch.stack([a,b],dim=0)
```
使用stack函数对0维度进行拼接是不行的
因为需要0维度的数值是相等的
![[Pasted image 20230509164157.png]]
```python
torch.cat([a,b],dim=0).shape
```
但是cat函数是可以使用的
![[Pasted image 20230509164246.png]]

**拆分的操作**
- split
是根据长度来区分的
假设现在有一个长度为6的tensor
现在给定拆分的步长或者是数量才能进行拆分
![[Pasted image 20230509164411.png]]

```python
b = torch.rand(32,8)
a.shape
c = torch.stack([a,b],dim=0)
c.shape

aa, bb = c.split([1,1],dim=0)
aa.shape, bb.shape

aa,bb = c.split(1,dim=0)
aa.shape, bb.shape
```
第一个参数是长度
第二个参数是维度
![[Pasted image 20230509164712.png]]
现在图中的意思是现在有两个班级的成绩单合并到一起之后的tensor
新的两个tensor指定为每个班的成绩单
这样我们拆分的维度确定了是班级的维度也就是dim0
然后每个班进行拆分 那么拆分的长度为1

如果我们现在是 3, 32, 8的tensor
我们现在是需要拆分出来2个普通班级和1个重点班级的成绩
这时候拆分需要不同的长度
我们的代码需要变换为
```python
aa, bb = c.split([2,1],dim=0)
```
可以看到 list 中的代码出现了变化
也是从0开始编号 从左往右进行划分
是否可以使用负数需要调查
但是list的特性应该是可以使用负数的

**容易出现报错的是**
```python
aa, bb = c.split(2,dim=0)
```
![[Pasted image 20230509165331.png]]
这里显示没有足够的值给拆分
等式的左边有两个等待赋值的变量名
等式右侧是分不出两个tensor
所以会报错

**按照数量拆分**
chunk
```python
aa, bb = c.chunk(2,dim=0)
aa.shape, bb.shape
```
![[Pasted image 20230509165542.png]]

出现的都是整数倍的拆分
