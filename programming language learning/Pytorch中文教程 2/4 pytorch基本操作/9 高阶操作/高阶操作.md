比较高级的
- where函数 条件的选取 源头是选自与A 或者 B
- gather函数 查表的操作

**where**
有3个参数
```python
torch.where(condition,x,y)   #Tensor
```
第一个是类似于true or false的选择项
第二个参数是类似于源头A 或者源头B
比如我现在有两项数据A B
生成了C
如果C 的数据全部来自于A 那 直接C =A
如果是部分来自于A 那就可以写作C【0】= A【0】
如果是C【0，0，1】
C【0，0，2】一个来自A 一个来自B
每个元素的具体来源都比较乱
![[Pasted image 20230509212905.png]]
这时候where可以起到的作用是给出一个condition的表
里面记载着各个位置对应的是来源于什么数据源的值
用0或者1来记载，假如现在又一个tensor是如图所示
1代表是这个位置的元素是来源于A中的这个同样位置的元素
0则是代表B 那么这个就形成一个表得出元素都是来源于什么

```python
cond
```
这个cond代表的是一个概率
![[Pasted image 20230509213726.png]]
这的概率越高是取A的概率更大，剩下的就是B的概率
将这些概率跟0.5进行比较会返回一个tensor
里面的0和1代表的是真或者假
![[Pasted image 20230509213838.png]]

为了能够更好的表示我们这里设置a全为0 b全为1
![[Pasted image 20230509213938.png]]

```python
torch.where(cond>0.5,a,b)
```
![[Pasted image 20230509214029.png]]
就可以看到上面probability的值大于0.5的都取了a当中的值也就是0
小于0.5的都取了b中的值也就是1

如何实现c中的取值是分别来自于a b数据源的操作判断
使用for循环
添加条件判断语句
如果满足条件就从a 或者b中取到特定值
![[Pasted image 20230509214312.png]]
如果使用for循环的话，在cpu上面跑，所以不并行不高效率

如果我们使用where语句，可以生成一个cond一个表
所以这样就会得到更高效的运行方式
![[Pasted image 20230509214507.png]]


**gather**
是一个查表的过程
一个表中存在几种动物的名字
![[Pasted image 20230509214646.png]]
现在我们有4个index代表动物
![[Pasted image 20230509214707.png]]
每个数字代表不同的动物
查表的操作也就是一个搜集的操作 也就是gather
![[Pasted image 20230509214758.png]]

第一个参数就是一张表
第二个参数是从什么维度上查表，这个因为只有0维度所以dim=0
第三个参数是给定需要查表的项
![[Pasted image 20230509214926.png]]
最后生成的一张表就是
![[Pasted image 20230509214940.png]]


具体的案例
现在对MNIST数据库进行手写数字识别
如果我们的结果是4，10的矩阵
这里的10代表的是概率
我们可以得到最大的概率和最大概率出现的位置
![[Pasted image 20230509215312.png]]
这里的位置的索引
其实就是对应的数字

但是如果我们来判断别的问题的情况下
例如我们的0-9的数字对应的是100-109
![[Pasted image 20230509215416.png]]
这个时候需要一个查表的操作
就可以把原来的结果转化到label上面
![[Pasted image 20230509215516.png]]
![[Pasted image 20230509215527.png]]

```python
prob = torch.randn(4,10)

idx = prob.topk(dim=1, k=3)
```
![[Pasted image 20230509215623.png]]
选择前三种最可能的结果
```python
idx = idx[1]
```
![[Pasted image 20230509215645.png]]
得出取得最大值的位置索引

![[Pasted image 20230509215821.png]]
这个是简单的权值变化，直接加100，可以这么操作
但是如果变化不是这么简单
就需要gather操作
在这里先创建一系列的label
```python
label = torch.arange(10) + 100 # 形成一个等差数列的张量
torch.gather(label.expand(4,10), dim=1, index=idx.long()) # 这是转换为64位浮点型的操作
```
dim是取前者的维度
因为前者expand成了二维张量 所以dim需要取1 就是对应的10
这里的index代表我们有batch 4个 每个 batch需要查3次表

限制条件是输入张量和索引张量必须有相同的维度数
索引张量的每个元素必须是有效的索引值，能够指定从输入张量的每一行取哪个值
如果有一个2x3的输入张量input和一个2x2的索引张量index，可以使用torch.gather(input, 1, index)来得到一个2x2的输出张量output，其中output ij = input i index ij 。