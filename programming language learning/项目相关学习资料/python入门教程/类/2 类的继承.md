## 类和函数的注释

```python
def sit(self):
	print(self.name.title())
```

```python
def A(a):  
    '''  
    Parameters  
    ----------    
    a  
    Returns    
    -------  
    '''    
    print(a)  
    return a  
  
A("ajdoa")
```
在生成只是之前需要检查setting中是否在
![[Pasted image 20231016162216.png]]
这里的format需要更改为其他选项，有四种默认的风格
[pycharm自动生成函数注释及注意事项-CSDN博客](https://blog.csdn.net/weixin_43698781/article/details/123767338)

## 类的继承是什么

继承是类和类的一种关系，子类可以直接继承父类的所有属性和方法， 同时，子类可以定义自己的属性和方法

### 为什么要有继承

使用继承可以有效实现代码的复用，避免重复代码的出现

比如我要写一个动物
动物首先都能够吃饭，但是不同的动物有的可以飞翔，有的可以跑步，所以我就可以在父类中定义吃饭，在子类中定义飞翔和跑步

```python
class Animal():  
    def __init__(self,name,age):  
        self.name = name  
        self.age = age  
  
    def eat(self, food):  
        print(self.name.title() + " is now eatting " + food + ".")  
  
class Dog(Animal):  
    def __init__(self,name,age,type):  
        super().__init__(name,age)  
        self.type = type  
    def sit(self):  
        print(self.name.title() + " is now sitting. ")  
    def get_character(self):  
        if self.type == 'teddy':  
            print(self.name + ' is cute. ')
```

调用父类
```python
my_dog = Dog('Hua', 2, 'teddy')  
my_dog.eat('apple')
```

调用子类中的方法
```python
my_dog.get_character()
```

比如在这里狗是不能吃什么东西
我们可以重写这个eat的类

#### 错误写法

```python
class Dog(Animal):  
    def __init__(self, name, age, type):  
        super().__init__(name, age)  
        self.type = type  
  
    def sit(self):  
        print(self.name.title() + " is now sitting. ")  
  
    def get_character(self):  
        if self.type == 'teddy':  
            print(self.name + ' is cute. ')  
  
    def eat(self, food):  
        if food == 'milk' or 'chocolate':  
            print(' Dog can not eat ' + food + '.')  
        else:  
            print(self.name + ' is now eatting ' + food + '.')  
  
  
my_dog = Dog('Hua', 2, 'teddy')  
my_dog.eat('apple')  
my_dog.eat('milk')  
my_dog.eat('chocolate')
my_dog.get_character()

'''
 Dog can not eat apple.
 Dog can not eat milk.
 Dog can not eat chocolate.
Hua is cute. 
'''
```

可以看到这里的dog是可以吃apple但是输出是不可以吃
因为在 if 这里写错了
这里的 or 后边是True，所以这个条件永远是True 就代表着一定会打印

```python
class Dog(Animal):  
    def __init__(self, name, age, type):  
        super().__init__(name, age)  
        self.type = type  
  
    def sit(self):  
        print(self.name.title() + " is now sitting. ")  
  
    def get_character(self):  
        if self.type == 'teddy':  
            print(self.name + ' is cute. ')  
  
    def eat(self, food):  
        if food == 'milk' or food == 'chocolate':  
            print(' Dog can not eat ' + food + '.')  
        else:  
            print(self.name + ' is now eatting ' + food + '.')  
  
  
my_dog = Dog('Hua', 2, 'teddy')  
my_dog.eat('apple')  
my_dog.eat('milk')  
my_dog.eat('chocolate')  
my_dog.get_character()
```

这样结果就正确了，但是这个还是不够简单，因为如果每一个food都需要写一个等式去forbid，这里可以采用列表

```python
class Dog(Animal):  
    def __init__(self, name, age, type):  
        super().__init__(name, age)  
        self.type = type  
  
    def sit(self):  
        print(self.name.title() + " is now sitting. ")  
  
    def get_character(self):  
        if self.type == 'teddy':  
            print(self.name + ' is cute. ')  
  
    def eat(self, food):  
        forbidden_foods = ['milk', 'chocolate']  
  
        if food in forbidden_foods:  
            print(' Dog can not eat ' + food + '.')  
        else:  
            print(self.name + ' is now eatting ' + food + '.')  
  
  
my_dog = Dog('Hua', 2, 'teddy')  
my_dog.eat('apple')  
my_dog.eat('milk')  
my_dog.eat('chocolate')  
my_dog.get_character()
```

这样代码的可编写的能力更强了

### 习惯写法

一般一个文件内只会定义一个类