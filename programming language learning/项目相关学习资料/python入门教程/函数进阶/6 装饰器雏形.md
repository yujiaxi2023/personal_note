retrieve
1. 函数可以作为参数进行传递
```python
def func():  
    print("我是函数")  
  
def gggg(fn): # fn要求是个函数  
    fn()  
  
gggg(func) # 此时相当于一个func()
```
2. 函数可以作为返回值进行返回
```python
def func():  
    def inner():  
        print("123")  
    return inner  
  
ret = func()  
ret()
```
3. 函数名可以当作变量进行赋值操作
```python
def func1():  
    print("我是函数1")  
  
def func2():  
    print("我是函数2")  
  
func1 = func2  
func1() # 我是函数2
```

装饰器decorator：
-> 记住最后的结论
```python
def play_dnf():  
    print("hello dnf")  
  
def play_lol():  
    print("hello lol")  
  
print("开挂")  
play_dnf()  
print("关闭外挂")  
  
print("开挂")  
play_lol()  
print("关闭外挂")
```
我现在需要玩两个游戏之前开挂
但是我不想每次都要操作开挂和关闭外挂两个操作
所以我定义一个函数
```python
def guanjia(game): # 作为一个管家打开关闭外挂  
    print("开挂")  
    game()  
    print("关闭外挂")  
  
def play_dnf():  
    print("hello dnf")  
  
def play_lol():  
    print("hello lol")

guanjia(play_dnf)
```
但是这时候是管家玩游戏
我们需要的是我们执行程序

```python
def guanjia(game): # 作为一个管家打开关闭外挂  
    def inner():  
        print("开挂")  
        game()  
        print("关闭外挂")  
    return inner  
  
def play_dnf():  
    print("hello dnf")  
  
def play_lol():  
    print("hello lol")  
  
play_dnf = guanjia(play_dnf) #  游戏现在是管家是重新封装的游戏  
play_dnf() # 此时运行的是管家给的内层函数inner
```
此时重新定义了一遍这个play_dnf

```python
def guanjia(game): # 作为一个管家打开关闭外挂  
    def inner():  
        print("开挂")  
        game()  
        print("关闭外挂")  
    return inner  
  
def play_dnf():  
    print("hello dnf")  
  
def play_lol():  
    print("hello lol")  
  
play_dnf = guanjia(play_dnf) #  游戏现在是管家是重新封装的游戏  
play_dnf() # 此时运行的是管家给的内层函数inner  
  
# 同样的道理  
play_lol = guanjia(play_lol) # 让管家重新封装lol  
play_lol()
```
但是这样封装也难以阅读

这时候我们可以对这个游戏进行标记，这样就可以进行操作
```python
def guanjia(game): # 作为一个管家打开关闭外挂  
    def inner():  
        print("开挂")  
        game()  
        print("关闭外挂")  
    return inner  
  
@guanjia # 相当于play_dnf = guanjia(play_dnf)  
def play_dnf():  
    print("hello dnf")  
  
@guanjia  
def play_lol():  
    print("hello lol")  
  
play_lol()  
play_dnf()
```

**装饰器**
1. 本质上是一个闭包，需要的是内层函数调用一个局部变量，但是这个局部变量是一个函数
	作用：
		在不改变原有函数调用的情况下，给函数添加新的功能
		可以在函数前后添加新功能，不改变源代码
		
	使用案例：
		登录系统并修改信息
		日志系统
		
	雏形：
```python
def wrapper(fn): wrapper:装饰器，fn:目标函数
	def inner():
		# 在目标函数执行之前···
		fn() # 执行目标函数
		# 在目标函数执行之后···
		return inner
```