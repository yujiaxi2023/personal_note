```python
for args in iterations:
	pass
```
如果不是可迭代的东西，就会报错是不可迭代的东西
iterable可迭代的东西
str list tuple dict set open()

可迭代的数据类型都会提供迭代器，这个迭代器可以帮我们把数据类型中的所有数据逐一拿到

python中获得迭代器的两种方案：
1. iter()内置函数可以拿到迭代器
```python
it = iter("what is your name?")
print(it)
```

2. `__iter__()` 一种特殊的方法
```python
it = "heheda".__iter__()  
print(it)  
```

从迭代器中拿到数据：
1. next()内置函数
```python
it = iter("what is your name?")
print(next(it)) # w
print(next(it)) # h
```
这里的next只能拿迭代器中限定长度的数据，如果超过迭代器的长度就会报错
这里可以发现迭代器就是一个一次性的东西
2. `__next__()` 一种特殊方法
```python
it = "haeheda"
print(next(it))  
print(it.__next__())
```

for循环的工作原理
```python
# for循环的工作原理  
s = "iiihoqhefr"  
it = s.__iter__()  
while 1:  
    data = it.__next__()  
    print(data) # for 循环的循环体
```
但是上述的操作一定会报错
这里我们可以使用try操作
```python
# for循环的工作原理  
s = "iiihoqhefr"  
it = s.__iter__()  
while 1:  
    try:  
        data = it.__next__()  
        print(data) # for 循环的循环体  
    except StopIteration:  
        break
```
这里try是检查程序怎么报错的
如果程序是StopIteration的报错，就变为break命令

for循环中一定要拿迭代器
```python
for i in 123:
	print(i)
```
为什么这里报错，就是因为123的数据无法进行迭代，无法使用迭代器
for循环里面一定有`__next__()`这种拿数据的操作出现

**总结**
迭代器本身统一了所有不同数据类型的遍历工作

1. 迭代器本身也是可迭代的
```python
s = "nihao"  
it = s.__iter__()  
  
for mm in it:  
    print(mm) # 这也不会报错,但是实际上it是迭代器
```
2. 迭代器只能向前不能反复
所有的可迭代数据都是有顺序的，包括集合set和dict
所以next操作一定是有方向的

3. 特别省内存
迭代器内部存储了一个指针一样的内容

4. 惰性机制
迭代器只有在调用（访问）next的时候才会往前迭代