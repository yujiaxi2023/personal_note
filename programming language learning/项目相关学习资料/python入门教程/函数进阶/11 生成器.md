生成器本质上是迭代器

创建生成器的两种方案：
1. 生成器函数
2. 生成器表达式

生成器函数
	生成器函数中由一个关键字yield
	如果将函数中的return变为yield，生成器函数在函数执行的时候不会执行函数，而是得到的生成器

```python
def func():  
    print(123456)  
    yield 999  
  
ret = func()  
print(ret) # <generator object func at 0x000001B2D5E906D0>
```

如果使用生成器是使用迭代器进行的
```python
def func():  
    print(123456)  
    yield 999  
  
ret = func()  
print(ret.__next__()) 
```
yield只有在执行next的时候才会返回结果数据
如果使用两次next
```python
def func():  
    print(123456)  
    yield 999  
  
ret = func()  
print(ret.__next__()) 
print(ret.__next__()) 
```
会报错StopIteration
这代表着迭代器中已经迭代完了，说明yield返回的是一个值

yield：只要函数中出现了yield，就是一个生成器函数
1. 可以返回数据
2. 可以分段执行函数中的内容,通过next可以执行到下一个yield的位置
```python
def func():  
    print(123)  
    yield 666  
    print(456)  
    yield 999  
    ret = func()  
print(ret.__next__()) # 生成器开始执行  
print(ret.__next__())
```

生成器的作用
当我的数据生成的大量的数据，但是一次性无法使用的时候，或者不需要一次性使用的时候，就可以考虑生成器来节约内存

```python
# 去工厂定制一万件衣服  
def order():  
    lst = []    for i in range(10000):  
        lst.append(f"cloth{i}")  
    return lst  
  
lst = order()  
print(lst)
```
这里就是工厂生产了一万件衣服，然后我接受之后一次性就穿一万件，这太臃肿了在内存中

所以我们需要把函数变为生成器，例如一次我只穿50
```python
def order():  
    lst = []  
    for i in range(10000):  
  
        lst.append(f"cloth{i}")  
        if len(lst) == 50:  
            yield lst  
  
            # 下一次拿数据，是一个空列表，内存就清空了
            lst = []  
  
gen = order()  
print(gen.__next__())
```
如果我还需要更多的，那就接着next操作

用好了就可以节省内存