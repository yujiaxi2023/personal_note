```python
def guanjia(game):  
    def inner(*args, **kwargs):  
        print("开挂")  
        game(*args, **kwargs)  
        print("关闭外挂")  
  
    return inner  
  
def play_dnf(username, password):  
    print("开始游戏dnf", username, password)  
    print("hello dnf")  
    return "屠龙刀"  
  
  
def play_lol(username, password, hero):  
    print("开始游戏lol", username, password, hero)  
    print("hello lol")  
  
  
ret = play_dnf("admin", "123")  
print(ret)
```
正常情况下这里运行ret的时候返回值是添加了屠龙刀
如果添加了装饰器
```python
def guanjia(game):  
    def inner(*args, **kwargs):  
        print("开挂")  
        game(*args, **kwargs)  
        print("关闭外挂")  
  
    return inner  

@guanjia
def play_dnf(username, password):  
    print("开始游戏dnf", username, password)  
    print("hello dnf")  
    return "屠龙刀"  
  
  
def play_lol(username, password, hero):  
    print("开始游戏lol", username, password, hero)  
    print("hello lol")  
  
  
ret = play_dnf("admin", "123")  
print(ret)
```
这里就无法返回“屠龙刀”
这是因为使用ret的时候返回的时inner函数，而inner函数中没有返回值
所以需要在inner中添加返回值
```python
def guanjia(game):  
    def inner(*args, **kwargs):  
        print("开挂")  
        ret = game(*args, **kwargs) # 这里是目标函数的执行,这里是能够拿到从目标函数的返回值的  
        print("关闭外挂")  
        return ret  
  
    return inner  
  
  
@guanjia  
def play_dnf(username, password):  
    print("开始游戏dnf", username, password)  
    print("hello dnf")  
    return "屠龙刀"  
  
  
def play_lol(username, password, hero):  
    print("开始游戏lol", username, password, hero)  
    print("hello lol")  
  
  
ret = play_dnf("admin", "123") # 调用的inner函数,inner中没有返回值  
print(ret)
```

### **通用装饰器的写法：**
```python
def wrapper(fn): # wrapper: decorator, fn: target function
	def inner(*args, **kwargs):
		# 目标函数执行之前···
		ret = fn(*args, **kwargs) # 执行目标函数
		# 目标函数执行之后
		return ret
	return inner # 不要加inner()

@wrapper
def target():
	pass

target() # => inner()
```

一个函数可以被多个装饰器装饰
```python
def wrapper1(fn): # 此时fn时wrapper2.inner  
    def inner(*args, **kwargs):  
        print("this is wrapper1 in") # 第一步  
        ret = fn(*args, **kwargs) # wrapper2.inner  
        print("this is wrapper1 out") # 第五步出来  
        return ret  
    return inner  
  
def wrapper2(fn):  
    def inner(*args, **kwargs):  
        print("this is wrapper2 in") # 第二补出来  
        ret = fn(*args, **kwargs) # target  
        print("this is wrapper2 out") # 第四步出来  
        return ret  
    return inner  
  
@wrapper1 # target = wrapper1(target) = wrapper1(wrapper2.inner) => target:wrapper1.inner  
@wrapper2 # wrapper2先套在target上 target = wrapper2(target) => target:wrapper2.innerdef target():  
    print("target funciton!") # 第三步出来  
  
target()  
"""  
this is wrapper1 in  
this is wrapper2 in  
target funciton!  
this is wrapper2 out  
this is wrapper1 out  
"""
```
如果是多个装饰器，最中间一定是target function
这个顺序一定是wrapper1前半部分 wrapper2前半部分 target wrapper2后半部分 wrapper1后半部分
