面向对象中有这样的理念,是子类可以继承父类中的方法和类变量(不是拷贝一份,父类还是属于父类,子类可以继承而已)
```
父类
子类

Base 基类
派生类
```
![[Pasted image 20231030144238.png]]
```python
class Base:  
  
    def func(self):  
        print("Base.funb")  
  
# 通过括号来显示继承自什么类  
class Son(Base):  
  
    def show(self):  
        print("Son.show")  
  
# 可以执行类中间的方法,也可以执行父类的方法  
# 但是优先是在自己的类中找有没有这个方法,如果没有就去父类中寻找  
# 并没有把父类的方法拿到子类中间,而是可以到父类中寻找  
s1 = Son()  
s1.show()  
s1.func()  
  
s2 = Base()  
s2.func()
```
是一种程序的调用过程

**继承的意义**
帮助我们实现代码的重复使用

```python
class Foo:  
  
    def f1(self):  
        pass  
  
    def f2(self):  
        pass  
  
class Bar:  
  
    def f1(self):  
        pass  
  
    def f3(self):  
        pass  
  
# 发现Bar和Foo的代码中,方法的代码是一样的,这样以后维护也费劲,写的时候也费劲,所以我们可以把共同的放在基类中
```
可以把共同代码放在基类中
```python
class Base:  
    def f1(self):  
        pass  
  
class Foo(Base):  
    def f2(self):  
        pass  
  
class Bar(Base):  
    def f3(self):  
        pass  
  
o1 = Foo()  
o1.f2()  
o1.f1()
```

## 练习题

对于初学者来说需要把握住self是哪个类的对象,需要到这个关联的类中寻找方法

```python
"""  
# 1.  
class Base:  
    def f1(self):        print("base.f1")  
class Foo(Base):  
    def f2(self):        print("foo.f2")  
obj = Foo()  
obj.f1()  
obj.f2()  
"""  
"""  
# 2.  
class Base:  
    def f1(self):        print("base.f1")  
class Foo(Base):  
    def f2(self):        print("before")        self.f1() # 调用f1方法  
        # 这里相当于执行了obj.f1()  
        # Foo中间没有找到,就回去Base中找到  
        print("foo.f2")  
obj = Foo()  
obj.f2()  
# before  
# base.f1  
# foo.f2  
"""  
"""  
# 3.  
class Base:  
    def f1(self):        print("base.f1")  
class Foo(Base):  
    def f2(self):        print("before")        self.f1()        print('foo.f2')    def f1(self):        print("foo.f1")  
obj = Foo()  
obj.f1() # 这里执行的是Foo中的f1 foo.f1  
obj.f2() # 这里传入的self是obj,是Foo,所以也是Foo中的f1 foo.f1  
# before  
# foo.f1  
# foo.f2  
"""  
"""  
# 4.  
class Base:  
    def f1(self):        print("before")        self.f2()        print("base.f1")  
    def f2(self):        print("base.f2")  
class Foo(Base):  
    def f2(self):        print("foo.f2")  
obj = Foo()  
obj.f1() # 会从Foo中找,但是没有,找Base有  
# 执行Base.f1方法的时候,调用了一个f2  
# 这时候self是Foo,所以是在Foo找f2 打印foo.f2  
# before  
# foo.f2  
# base.f1  
  
b1 = Base()  
b1.f1()  
# f1对象是Base类的对象,打印before,self此时是b1也就是Base类  
# 调用f2就是Base类的,也就是base.f2  
# 最后是base.f1  
# before  
# base.f2  
# base.f1  
"""  
"""  
# 5.  
class TCPServer:  
    def f1(self):        print("TCP.f1")  
    def f2(self):        print("TCP.f2")  
  
class ThreadingMixIn:  
    def f1(self):        print("Thread.f1")  
class ThreadingTCPServer(ThreadingMixIn, TCPServer):  
    def run(self):        print("before")        self.f1()        print("after")  
    def run_1(self):        print("before")        self.f1()        self.f2()        print("after")  
  
obj = ThreadingTCPServer()  
obj.run()  
  
# 代表这个类继承两个类,python支持多继承,很多语言是不支持的  
# 这个时候出现了优先级的区别了  
# 先print before,优先级是先找左边的父类,然后找右边的父类  
# 如果左边的父类找到了,就在左边,如果左边的没有,就找右边,找到的第一个就是调用的方法  
# before  
# Thread.f1  
# after  
  
obj_1 = ThreadingTCPServer()  
obj_1.run_1()  
# before  
# Thread.f1  
# TCP.f2  
# after  
"""  
# 6.  
class BaseServer:  
    def serve_forever(self, poll_interval=0.5):  
        self._handle_request_noblock()  
  
    def _handle_request_noblock(self,request, client_address):  
        self.process_request(request, client_address)  
  
    def process_request(self, request, client_address):  
        pass  
  
class TCPServer(BaseServer):  
    pass  
  
class ThreadingMixIn:  
    def process_request(self, request, client_address):  
        pass  
  
class ThreadingTCPServer(ThreadingMixIn, TCPServer):  
    pass  
  
obj = ThreadingTCPServer()  
obj.serve_forever()  
  
# ThreadingTCPServer中继承了两个类, TCPServer继承了BaseServer  
# 所以找方法发流程是在ThreadingTCPServer中找,如果没有  
# 在ThreadingMixIn中找,如果还是没有  
# 在TCPServer中找,如果还是没有  
# 在BaseServer中找,如果没有就报错  
# 执行的self是obj,这是ThreadingTCPServer这个类,找_handler_request_noblock的时候也要重新开始找  
# 然后会找process_request方法,也是重新来ThreadingTCPServer中找,然后去ThreadingMixIn中找到了
```
![[Pasted image 20231030154918.png]]

## 总结

- 在执行某个对象的方法的时候,优先在对象所关联的类中寻找方法,没有才会在父类中进行寻找
- 如果父类没有就继续向上找,直到没有,就会报错
- 如果有多继承,目前记住,先从左边继承,再去右边继承
- 如果存在继承之后,找执行过程的时候一定要记住self是谁,就要去self对应的类中获取成员,没有就按照继承关系向上查找
