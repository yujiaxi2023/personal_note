- 方式一：模块导入
- 方式二：并发编程
- 方式三：单例模式

```python
class MyType(type):  
  
    def __init__(self, name, bases, attrs):  
        print("init")  
        super().__init__(name, bases, attrs)  
        # 学习wtforms，可以在这里也创建两个变量  
        self.instance = None  
  
    def __new__(cls, *args, **kwargs):  
        # 创建类  
        print("new")  
        new_cls = super().__new__(cls, *args, **kwargs)  
        print(new_cls)  
        return new_cls  
  
    def __call__(self, *args, **kwargs):  
        # 1. 先判断是否已经有对象，有就不创建，没有就创建  
        if not self.instance:  
            self.instance = self.__new__(self)  
        # 调用自己类的new方法 创建对象  
        # empty_object = self.__new__(self)  
        # 调用自己类init进行初始化  
        self.__init__(self.instance, *args, **kwargs)  
  
        return self.instance  
  
# 假设Foo是一个对象，由MyType创建  
# Foo类是MyType的一个对象  
# Foo() -> MyType对象()  
class Foo(object, metaclass=MyType):  
  
    # 类变量：创建的对象  
    # instance = None  
    pass  
  
  
v1 = Foo() # 真正的创建对象并设置instance 并 返回给v1  
v2 = Foo()  
print(v1)  
print(v2)  
# 此时v1和v2的内存地址一摸一样就形成了单例模式  
# 类从上到下只创建一次  
# 如果没有继承MyType，那就无法实现单例模式了，两个内存就不一样了  
  
# 如果不想要每次都继承，觉得很麻烦  
# 我们就打包一个singleton的类用来继承MyType，这样就可以通过Singleton继承定义的metaclass  
class Sigleton(object, metaclass=MyType):  
    pass  
  
class Foo1(Sigleton):  
    pass  
  
class Foo2(Sigleton):  
    pass  
  
v3 = Foo1()  
v4 = Foo1()  
v5 = Foo2()  
v6 = Foo2()  
print(v3, v4)  
print(v5, v6)
```

单例模式就是表示由一个类创建的多个目标都是储存在同一个内存中的同样的目标