## 递归锁

**死锁**

互斥锁使用过程中，如果使用不当，就是没有Lock.release。进程或者线程都会出现死锁。就是两个或者两个以上的进程和线程执行中，因为争夺资源造成的互相等待的现象，如果没有外力作用，都不能推进下去。

```python
from threading import Lock  
# from multiprocessing import Lock  
  
if __name__ == '__main__':  
    lock = Lock()  
    with lock:  
        with lock:  
            print("互斥锁使用不当导致死锁") # 这段话永远不能运行
```
这段代码就是加了多次锁，没有进行释放
对同一把锁添加了多次
多把锁也可能出现死锁现象

典型问题，科学家吃面，代码：
```python
import time  
from threading import Thread, Lock  
  
noodle_lock = Lock()  
fork_lock = Lock()  
  
def eat1(name):  
    """  
    先抢面条再抢筷子  
    """    noodle_lock.acquire()  
    print(f"{name}抢到了面条")  
    fork_lock.acquire()  
    print(f"{name}抢到了筷子")  
    time.sleep(0.1)  
    print(f"{name}吃面")  
    fork_lock.release()  
    noodle_lock.release()  
  
def eat2(name):  
    """  
    先抢筷子再抢面条  
    """    fork_lock.acquire()  
    print(f"{name}抢到了筷子")  
    noodle_lock.acquire()  
    print(f"{name}抢到了面条")  
    time.sleep(0.1)  
    print(f"{name}吃面")  
    fork_lock.release()  
    noodle_lock.release()  
  
if __name__ == '__main__':  
    for name in ["a", "b", "c", "d"]:  
        Thread(target=eat1, args=(name, )).start()  
        Thread(target=eat2, args=(name, )).start()  
        """  
        a抢到了面条  
        a抢到了筷子  
        a吃面  
        a抢到了筷子  
        b抢到了面条  
                然后程序就不动了  
        """
```
一桌子人吃面，需要抢到面和筷子才能吃到面
![[Pasted image 20240214145215.png]]

这时候我们需要使用递归锁（RLock）来解决

这里让面条锁和筷子锁是同时抢占的资源
![[Pasted image 20240214150359.png]]
针对同一个资源添加多个锁
线程1进入了之后上锁，上多次进行多层锁定
只要上了第一个锁其他的线程就会一直等待

```python
import time  
from threading import Thread, RLock  
  
fork_lock = noodle_lock = RLock()  
  
def eat1(name):  
    """  
    先抢面条再抢筷子  
    """    noodle_lock.acquire()  
    print(f"{name}抢到了面条")  
    fork_lock.acquire()  
    print(f"{name}抢到了筷子")  
    time.sleep(0.1)  
    print(f"{name}吃面")  
    fork_lock.release()  
    noodle_lock.release()  
  
  
def eat2(name):  
    """  
    先抢筷子再抢面条  
    """    fork_lock.acquire()  
    print(f"{name}抢到了筷子")  
    noodle_lock.acquire()  
    print(f"{name}抢到了面条")  
    time.sleep(0.1)  
    print(f"{name}吃面")  
    fork_lock.release()  
    noodle_lock.release()  
  
  
if __name__ == '__main__':  
    for name in ["a", "b", "c", "d"]:  
        Thread(target=eat1, args=(name,)).start()  
        Thread(target=eat2, args=(name,)).start()
```
只需要换一个包就可以了
所以这个就会在abcd全部吃完之后就会结束程序

python中，不仅是threading，还有multiprocessing中都是内置了可重入锁（RLock），也就是递归锁，就是可以针对同一个进程或者同一个线程内，同一把锁可以添加多次锁。RLock内部维护一个Lock锁和counter计数器变量，计数器counter记录了acquire添加锁的次数，从而让资源可以被多次添加锁，直到所有的添加锁都被释放了，其他的线程才能获得资源。递归锁也是互斥锁，所以同时出现多个递归锁，还是会导致死锁的情况。

```python
from threading import RLock
mutex = RLock()
mutex.acquire()
print("执行代码内容1")
mutex.acquire()
print("执行代码内容2")
mutex.release()
mutex.release()
```
这里两句话都执行了
这里有多次加锁和释放操作，但是因为是递归锁，所以不会影响程序执行，不会出现死锁现象

