## 互斥锁mutex

全局解释器锁GIL锁并不能保证一定不会出现数据一致性的问题，因为在计算密集型任务中，因为分配给每个时间片的时间是很短的，所以计算超大数据的时候重新回到时间片的时候会少计算一次。

**非线程安全 not-safe threading**
线程之间存在资源竞争的状态，一个全局变量经过多个线程的并发操作，最后的结果会出现异常，这就是非线程安全

**线程安全 safe threading**
如果使用互斥锁保证这个全局变量在多个线程并发的情况下，代码执行结果不出现偏差就是线程安全。python中存在全局解释器和锁机制，所以python中并不会出现非线程安全的问题。如果使用其他的语言PHP或者Java经常会出现线程安全的问题。


进程所和线程里面的Lock机制，和全局解释器锁都是互斥锁，互斥锁对于共享数据进行锁定，可以保证在同一时间内只有一个进程或者线程操作同一个共享数据，这样就可以有效的解决资源抢夺问题。

#### 示例以两个线程操作循环为例子
在多线程环境下，当访问共享资源时，可能会产生不一致的结果，这与时间片轮转和并发操作有关。让我们通过一个具体的例子来说明：

假设有两个线程（Thread A和Thread B）同时访问一个共享的计数器变量，初始值为0。每个线程都执行一个循环，每次循环都将计数器加1。如果每个线程在一个时间片内能够执行一次循环，那么情况可能如下：

初始状态：计数器值为0。
时间片1：Thread A执行一次循环，将计数器加1（计数器值变为1）。
时间片2：Thread B执行一次循环，将计数器再次加1（计数器值变为2）。
时间片3：Thread A再次执行一次循环，将计数器再次加1（计数器值变为3）。
...

假设在某个时刻，线程切换导致Thread A和Thread B都在执行计数器加1的操作。如果在下个时间片回到Thread A时，它执行了计数器加1的操作，但由于线程切换，Thread B的操作也生效，那么实际上计数器只增加了1，而不是2。这就是典型的竞态条件，导致了不一致的结果。

在这个例子中，由于时间片的切换和并发执行，两个线程在访问共享资源时相互干扰，使得最终的计数器值不符合预期。解决这类问题通常需要使用同步机制，如互斥锁，以确保在任何时刻只有一个线程能够修改共享资源，从而避免竞态条件和不一致性的问题。

在多线程环境中，线程切换是由操作系统决定的，而不是由程序控制的。当一个线程的时间片用完或者发生了某些事件（比如等待IO完成）时，操作系统会暂停当前线程的执行，并将CPU资源分配给其他就绪状态的线程。在这个过程中，可能会出现下一个时间片回到Thread A的时候，同时线程切换到Thread B并且其操作也生效的情况，这是因为操作系统会根据一定的调度算法来选择下一个要执行的线程，而线程之间的切换并不受程序的控制，因此可能导致多个线程在同一时间片内都得到执行机会。

这种情况下，多个线程同时访问共享资源可能导致竞态条件，从而产生不一致的结果。为了避免这种情况，需要使用同步机制来确保在任何时刻只有一个线程能够修改共享资源，从而避免竞态条件和数据不一致性的问题。

是的，你理解得很准确。在多线程环境中，时间片操作和调度线程操作是两个独立但相关的操作，它们可能在同一时刻发生，导致竞态条件和不一致的结果。

具体来说，当上一个时间片执行的最后一次是Thread A执行了某个操作，然后时间片回到了Thread A时，如果此时操作系统的调度算法选择切换到Thread B，那么Thread B的操作也会生效。这时候就出现了矛盾，因为在Thread A的执行中，某个操作已经被执行，但由于线程切换到了Thread B，Thread B的操作也在同一时间片内生效，导致最终的结果不一致。

为了解决这个问题，需要使用同步机制，如互斥锁，确保在任何时刻只有一个线程能够修改共享资源，以避免竞态条件和数据不一致性。这帮助确保在共享资源上的操作能够有序进行，而不会受到并发执行和线程切换的影响。




threading也有Lock变量，也就是调用一个互斥锁，提供给多个操作同一变量的同步阻塞操作。

```python
import dis  
from threading import Thread, Lock  
  
num = 0  
  
def func(lock):  
    lock.acquire()  
    global num  
    # 大批量执行计算操作，一般叫做计算密集型任务  
    for i in range(2000000):  
        num += 1  
    lock.release()  
  
  
if __name__ == '__main__':  
    # dis.dis(func) # 获取CPU在运行指定变量/函数的内部执行指令  
    # 创建一个互斥锁，让多个线程共享操作这把锁  
    lock = Lock()  
    thread_list = []  
    for i in range(10):  
        t = Thread(target=func, args=(lock, ))  
        t.start()  
        thread_list.append(t)  
  
    for t in thread_list:  
        t.join()  
  
    print(num) # 2000000
```
一定要解锁
另一种方法使用with比较好
```python
import dis  
from threading import Thread, Lock  
  
num = 0  
  
def func(lock):  
    # lock.acquire()  
    # global num    # # 大批量执行计算操作，一般叫做计算密集型任务  
    # for i in range(2000000):  
    #     num += 1    # lock.release() # 一定要解锁  
  
    # 方式2 使用with上下文管理器  
    global num  
    with lock:  
        for i in range(2000000):  
            num += 1  
  
  
  
if __name__ == '__main__':  
    # dis.dis(func) # 获取CPU在运行指定变量/函数的内部执行指令  
    # 创建一个互斥锁，让多个线程共享操作这把锁  
    lock = Lock()  
    thread_list = []  
    for i in range(10):  
        t = Thread(target=func, args=(lock, ))  
        t.start()  
        thread_list.append(t)  
  
    for t in thread_list:  
        t.join()  
  
    print(num) # 2000000
```
非线程安全是指在多线程环境中，当多个线程同时访问某个共享资源时，没有足够的保护措施来确保数据的一致性和完整性。具体而言，如果一个操作涉及多个步骤，而多个线程可以在同一时间执行这些步骤，那么在没有适当同步机制的情况下，可能导致数据竞争和不确定的结果。

在非线程安全的情况下，多个线程可能会同时修改共享数据，导致数据混乱或损坏。这可能是由于缺乏适当的互斥锁或其他同步手段，使得线程无法正确地协调其对共享资源的访问。

解决非线程安全的问题通常需要使用同步机制，如互斥锁（Mutex）或信号量（Semaphore），以确保在任何时刻只有一个线程能够访问共享资源，从而防止竞态条件和数据不一致性。

#### 资源抢占问题

并发编程中无论是进程还是线程并发，都会导致资源抢占的问题，使用锁可以保证安全问题但是牺牲了运行速度

如果锁代码的粒度很小，导致加锁解锁会浪费CPU资源
```python
import dis  
from threading import Thread, Lock  
  
num = 0  
  
def func(lock):  
    # lock.acquire()  
    # global num    # # 大批量执行计算操作，一般叫做计算密集型任务  
    # for i in range(2000000):  
    #     num += 1    # lock.release() # 一定要解锁  
  
    # 方式2 使用with上下文管理器  
    global num  
      
	for i in range(200000): 
		with lock: 
			num += 1  
  
  
  
if __name__ == '__main__':  
    # dis.dis(func) # 获取CPU在运行指定变量/函数的内部执行指令  
    # 创建一个互斥锁，让多个线程共享操作这把锁  
    lock = Lock()  
    thread_list = []  
    for i in range(10):  
        t = Thread(target=func, args=(lock, ))  
        t.start()  
        thread_list.append(t)  
  
    for t in thread_list:  
        t.join()  
  
    print(num) # 2000000

```

CPU只要遇到阻塞就会切换

### 并发条件下的单例模式

单例模式：singleton pattern
单例模式是在程序多次实例化的时候产生同一个对象，目的是为了减少创建对象和销毁对象过程中损耗的计算机资源

比如项目开发过程中的日志和商城购物车这些操作


如果计算机资源有限，或者创建对象的时候遇到阻塞，也会出现非线程安全问题

```python
import time  
from threading import Thread  
# 单例模式：保证程序多次实例化只会产生同一个对象，目的是为了减少创建对象和销毁对象这个过程损耗的计算机资源  
  
class Singleton(object):  
    __instance = None  
  
    def __new__(cls, *args, **kwargs):  
        if cls.__instance is None:  
            # 1. 代码量多了，遇到阻塞  
            # 2. 计算机资源有限  
            time.sleep(0.01)  
            cls.__instance = super().__new__(cls)  
  
        return cls.__instance  
  
class Human(Singleton):  
    def __init__(self, name, age):  
        self.name = name  
        self.age = age  
  
def create_people():  
    xm = Human("xiaoming", 20)  
    print(xm)  
  
if __name__ == '__main__':  
    for i in range(20):  
        thread = Thread(target=create_people)  
        thread.start() # 打印出来的xiaoming内存地址一样，代表创建的是单例  
        # 实际上并不是非常可靠  
        # 如果添加了time.sleep就可能不一样了，因为阻塞就会切换，切换之后就不一定在同一内存下
```

在多线程的时候创建的单例，实际上是同时在一个进程中的
所以拿到的对象是同一个进程下的数据集中的
当遇到阻塞之后就会切换，到另外的线程，就一样会切换
在线程中只要判断过一次，因为是共享的，所以会重新执行更改数据集
所以每次都会产生对数据集的影响
![[Pasted image 20240214134508.png]]


##### 线程安全单例模式（ThreadSafeSingleton）

```python
import time  
from threading import Thread, Lock  
  
  
# 单例模式：保证程序多次实例化只会产生同一个对象，目的是为了减少创建对象和销毁对象这个过程损耗的计算机资源  
  
class Singleton(object):  
    __instance = None  
  
    def __new__(cls, *args, **kwargs):  
        lock = args[0]  
        with lock:  
            if cls.__instance is None:  
                # 1. 代码量多了，遇到阻塞  
                # 2. 计算机资源有限  
                time.sleep(0.01)  
                cls.__instance = super().__new__(cls)  
  
            return cls.__instance  
  
  
class Human(Singleton):  
    def __init__(self, lock, name, age,):  
        self.name = name  
        self.age = age  
  
  
def create_people(lock,):  
    xm = Human(lock, "xiaoming", 20)  
    print(xm)  
  
  
if __name__ == '__main__':  
    lock = Lock()  
    for i in range(20):  
        thread = Thread(target=create_people, args=(lock, ))  
        thread.start()  # 打印出来的xiaoming内存地址一样，代表创建的是单例  
        # 实际上并不是非常可靠  
        # 如果添加了time.sleep就可能不一样了，因为阻塞就会切换，切换之后就不一定在同一内存下
```
上面这种写法非常诡异，因为传参lock需要从最开始传递到最后的单例类里面去，所以就非常奇怪

所以上面写法有问题
违背了面向对象设计原则
所以应该直接写在单例对象里面的
```python
import time  
from threading import Thread, Lock  
  
  
# 单例模式：保证程序多次实例化只会产生同一个对象，目的是为了减少创建对象和销毁对象这个过程损耗的计算机资源  
  
class Singleton(object):  
    """  
    Singleton实际上时类对象，实际上是在python经过了meta元类一开始创建出来的全局对象  
    """    __instance = None  
    __lock = Lock()  
  
    def __new__(cls, *args, **kwargs):  
        with cls.__lock:  
            if cls.__instance is None:  
                # 1. 代码量多了，遇到阻塞  
                # 2. 计算机资源有限  
                time.sleep(0.01)  
                cls.__instance = super().__new__(cls)  
  
            return cls.__instance  
  
  
class Human(Singleton):  
    def __init__(self, name, age,):  
        self.name = name  
        self.age = age  
  
  
def create_people():  
    xm = Human("xiaoming", 20)  
    print(xm)  
  
  
if __name__ == '__main__':  
    for i in range(20):  
        thread = Thread(target=create_people,)  
        thread.start()  # 打印出来的xiaoming内存地址一样，代表创建的是单例  
        # 实际上并不是非常可靠  
        # 如果添加了time.sleep就可能不一样了，因为阻塞就会切换，切换之后就不一定在同一内存下
```
因为类属性实际上就是类对象的实例属性，所以我们可以将线程安全单例模式的锁，以类属性创建并保存，这个类属性对于多线程来说也是共享资源

现在只考虑多线程下的单例模式，因为同一个进程下面的共享数据是公用的，容易导致程序出错，多进程下，因为不同进程保存数据的位置不一样，加上进程数量并不会开启很多，所以没有特殊业务，不会考虑多进程的单例模式，因为CPU进程最多开几十个，所以不会出现很大的性能损耗，加锁就可以了

