# 概念
线程（thread）也叫做轻量级进程，是计算机中CPU进行任务调度的最小单位，线程属于进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但是至少有一个线程，每次开启一个进程，都会默认拥有一个主线程，进程中实际的代码（代码段）运行就是通过调用CPU来完成的

进程是负责分配和隔离资源（内存，CPU）的，而线程是负责执行具体任务（代码）的，线程没有自己的系统资源的，同一个进程下的多个线程之间共享进程的系统资源，同时线程也需要操作系统创建，管理，切换，回收，但是线程需要的资源开销远远比进程要小。
线程有下面的特点：
1. 轻量级进程，是进程的轻量实体
2. 独立调度和分派任务的基本最小单位
3. 共享进程资源
4. 可并发执行

注意：python中的线程实现非常坑爹，很多优秀的应用程序都是多进程结合多线程实现的。

## 线程的组成

一个标准的线程由线程ID，当前指令指针，寄存器集合和堆栈组成，同时因为线程属于进程的实体，所以线程也有包括进程的程序段，数据集和独立的TCB控制块，这里是线程控制块不是PCB。
![[Pasted image 20240207201230.png]]
每一个线程都包含有寄存器和堆栈空间

### 线程和进程的区别

1. 地址空间和其他资源（例如打开文件）：进程之间相互独立，同一进程的各个线程之间共享资源，某个进程内的线程在其他进程中不可见
2. 通信：进程间通信采用IPC，而线程间可以直接读写进程数据段，例如全局变量来通信--需要进程同步（lock）和互斥手段的辅助，保证数据一致性  ----- 线程也存在并发问题
3. 调度和切换：线程的切换比进程的切换要快很多，资源开销更少
4. 在多线程操作系统中，进程不是一个可执行的实体，进程的执行需要依赖进程

python中提供多线程编程模块，thread，threading和Queue等
thread和threading模块允许开发人员创建和管理线程
thread模块提供最基本的线程和锁的支持，threading提供了更高级别，功能更强的线程管理功能。Queue模块允许用户传建议给可以用于多个线程之间共享数据的队列数据结构。一般使用threading比较多。

##### threading
threading的功能和之前学到的multiprocessing比较类似， 因为multiprocessing就是仿照threading写的，所以常用属性和方法是类似的

#### 线程的创建
基本使用，代码：
```python
import os  
from threading import Thread, current_thread  
  
import time  
  
def func():  
    time.sleep(2)  
    t = current_thread()  
    print(f"子线程运行了！子进程TID:{t.ident}")  
  
if __name__ == "__main__":  
    print(f"主进程PID: {os.getpid()}") # 在pycharm中运行，这个文件执行就是一个主进程了  
    # 进程不需要手动创建  
    t = Thread(target=func)  
    t.start() # 异步非阻塞操作，表示向操作系统申请调度创建线程，并不等待线程的创建和启动  
    thread = current_thread()  
    print(f"主线程执行了！主线程TID{thread.ident}") # 先打印这句话，所以并不阻塞  
    # 直接执行线程操作也没关系，因为window下面创建线程并不是创建进程，不需要复制进程空间import源代码  
    # 所以不写if判断也可以
```

创建单进程下多线程：
```python
from threading import Thread  
  
import time  
  
def func(name):  
    time.sleep(2)  
    print(f"{name}子线程运行了")  
  
if __name__ == "__main__":  
    # 单进程下的多线程  
    for i in range(10):  
        t = Thread(target=func, args=(f"{i}号",))  
        t.start()
```

开启多个进程下的多线程：
```python
import time  
from multiprocessing import Process  
from threading import Thread  
  
  
def thread_func(name, i):  
    time.sleep(2)  
    print(f"{name}进程的{i}子线程运行了")  
  
def func(name):  
    time.sleep(2)  
    print(f"{name}子进程运行了")  
    # 在子进程中开启多线程  
    for i in range(10):  
        t = Thread(target=thread_func, args=(name, f"{i}号"))  
        t.start()  
  
if __name__ == "__main__":  
    # 多进程下的多线程  
    for i in range(10):  
        t = Process(target=func, args=(f"{i}号",))  
        t.start()
```


基于面向对象的方法开启多线程任务
```python
import os  
import time  
from threading import Thread  
  
class Human(object):  
    def watch(self):  
        for i in range(3):  
            print("看电视....", os.getpid())  
            time.sleep(1)  
  
    def drink(self, drink):  
        for i in range(3):  
            print(f"喝{drink}...", os.getpid())  
            time.sleep(1)  
  
    def eat(self, food):  
        for i in range(3):  
            print(f"吃{food}...", os.getpid())  
            time.sleep(1)  
  
if __name__ == '__main__':  
    xiaoming = Human()  
    watch_process = Thread(target=xiaoming.watch)  
    drink_process = Thread(target=xiaoming.drink, kwargs={"drink":"water"})  
    eat_process = Thread(target=xiaoming.eat, args=("rice", ))  
  
    watch_process.start()  
    drink_process.start()  
    eat_process.start()
```

```python
from threading import Thread  
import time  
  
def func():  
    print("子线程要执行的任务代码")  
  
class MyThread(Thread):  
    def __init__(self, name, *args, **kwargs):  
        super().__init__(*args, **kwargs)  
        self.name = name  
  
  
    def run(self):  
        """run里面编写线程要执行的任务"""  
        print("线程运行前")  
        super().run()  
        print("线程运行后")  
  
if __name__ == '__main__':  
    t = MyThread(name="1号", target=func)  
    t.start()
```
