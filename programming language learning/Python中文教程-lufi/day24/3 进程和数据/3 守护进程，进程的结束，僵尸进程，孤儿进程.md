
## 守护进程 daemon

Daemon Porcess也叫精灵进程，是一种特殊的进程，一般在后台运行，不和任何控制终端相关联，并且**周期性执行**某种任务或者**等待处理**某些发生的事件（一般用于处理一些系统级别的任务）

#### 基本特点
- 生存周期长（非必须），一般启动后就会一直驻留在操作系统中，直到进程结束
- 守护进程是在后台运行，和终端没有关联，不会占着终端，终端可以执行其他的命令或者操作，终端退出，也不会导致守护进程退出，也因此守护进程中所有关于IO的操作都不能通过终端完成
- 主进程创建了守护进程后，守护进程会随着主进程的代码结束而自动结束，守护进程也是一个特殊的子进程
- 守护进程内不允许再开子进程

代码：
```python
import os  
import time  
from multiprocessing import Process  
  
def func():  
    for i in range(10):  
        time.sleep(10)  
        print(f"第{i}次子进程PID{os.getpid()}")  
  
if __name__ == "__main__":  
    print(f"主进程PID{os.getpid()}")  
    process = Process(target=func)  
    process.start()  
    time.sleep(300)  
    print("主进程代码结束")
```
![[Pasted image 20231227181729.png]]
![[Pasted image 20231227181757.png]]
![[Pasted image 20231227181817.png]]
看到这里开了两个python运行2个PID

```python
import time  
from multiprocessing import Process  
  
def mydaemon():  
    while True:  
        print("daemon is alive!")  
        time.sleep(5)  
  
if __name__ == "__main__":  
    p = Process(target=mydaemon)  
    # 设置当前子进程是守护进程，必须在start()前写  
    p.daemon = True  
    p.start()
```
这样写获得的进程会在主进程结束的时候立刻回收子进程
所以子进程根本来不及打印，如果想要看打印的结果，必须增加主进程的运行时间

```python
import time  
from multiprocessing import Process  
  
def mydaemon():  
    while True:  
        print("daemon is alive!")  
        time.sleep(1)  
  
if __name__ == "__main__":  
    p = Process(target=mydaemon)  
    # 设置当前子进程是守护进程，必须在start()前写  
    p.daemon = True  
    p.start()  
    time.sleep(5)

"""
daemon is alive!
daemon is alive!
daemon is alive!
daemon is alive!
daemon is alive!
"""
```

一般在操作系统中，守护进程的进程名称，往往以d结尾，例如web服务器的httpd，mysql的mysqld

#### 进程的结束
- 正常退出（自愿，例如用户点击交互式界面退出，或者程序执行完毕调用发起系统调用正常退出，在linux中用exit，win中ExitProcess）
- 出错退出（自愿，python中程序要读取一个a.py的内容，但是a.py不存在）这时候退出是python解释器自己处理的退出
- 严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try···except···）
- 被其他进程杀死（非自愿，如kill -9 pid）


多进程进行中，如果没有正常的结束进程，则会产生僵尸进程或者孤儿进程
#### 僵尸进程
任何一个进程（init除外）在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程（zombie process）的数据结构，等待父进程通过系统调用进行资源回收处理，这是每个进程在结束的时候都要经历的阶段，只是正常的进程结束，父进程会非常快的回收，我们无法感知

如果子进程在exit()之后，父进程没有来得及处理，这时候使用ps命令就可以看到子进程的状态是”Z“，这就是僵尸进程，是一种有害的进程，会浪费一定的系统资源，所以开发过程中一定要避免僵尸进程的出现
使用ps 命令查看stat列

什么情况下出现僵尸进程？子进程先退出，父进程没有进行回收操作就会产生僵尸进程
代码：
```python
import time  
import multiprocessing  
  
def func():  
    print("子进程执行了")  
    exit()  
  
if __name__ == "__main__":  
    process = multiprocessing.Process(target=func)  
    process.start() # 创建进程  
    time.sleep(30)
```
![[Pasted image 20231227185545.png]]
僵尸进程是每个进程结束必经的阶段，所以只要主程序未完成，子进程完成并结束，就会产生一个僵尸进程，所以这个代码在主进程结束之后会对这个僵尸进程进行回收
python中将进程回收进行了高度封装和安全处理

#### 孤儿进程Orphan Process
父进程退出，然后子进程还在运行，这个子进程就会称为孤儿进程
孤儿进程会被pid=0的初始进程init进程（系统的守护进程）所收养，init进程会对所有孤儿进程和资源回收，所以孤儿进程不会对系统造成危害
这个和垃圾回收不是一回事儿
```python
import os  
import time  
from multiprocessing import Process  
  
def func():  
    print(f"子进程的PID{os.getpid()}")  
    time.sleep(60)  
    print("hello")  
  
if __name__ == "__main__":  
	print(f"主进程的PID{os.getpid()}")
    p = Process(target=func)  
    p.daemon = True  
    p.start()  
    time.sleep(30)  
    #exit() # 关闭主进程
```
上面代码运行之后就执行
```
ps aux|grep 代码文件名（没有中文）
kill -9 主进程PID
```
就可以看到我们的子进程就变成了一个孤儿进程
![[Pasted image 20231227202415.png]]
![[Pasted image 20231227202425.png]]
这样执行就会出现两个进程，此时kill了父进程，子进程就会变成孤儿进程
linux可以用htop展示孤儿进程
```
htop
```
孤儿进程有时候可以通过监听是否存在孤儿进程来监视父进程
父进程意外退出了，可以对父进程进行收尸



### 守护进程（Daemon Process）
是在计算机系统中以服务方式运行的一类特殊进程。它在后台运行，不受用户控制，独立于终端并且通常用于执行系统级别的任务。下面详细解释一下守护进程及其用途：

#### 特点和属性：

- 后台运行： 守护进程在后台默默地执行，通常没有与用户界面的交互。
- 独立于终端： 它们不受终端连接的影响，不会受到用户退出登录的影响。
- 生命周期： 守护进程通常在系统启动时启动，一直运行到系统关闭或者显式地被终止。
- 无用户交互： 守护进程通常不与用户直接交互，它们被设计为在系统级别上提供服务。

#### 用途：

- 服务管理： 守护进程常用于管理系统服务，如网络服务、打印服务等。它们可以在系统启动时自动启动，并在系统运行期间监控和维护这些服务。
- 定时任务： 一些守护进程负责执行定时任务，例如系统备份、日志清理等，以确保系统的正常运行和维护。
- 资源管理： 守护进程也可以用于监控和管理系统资源，确保资源的合理分配和优化使用。
- 事件处理： 在某些情况下，守护进程被用于监测特定事件，如文件变化、网络状态变化等，并采取相应的措施来处理这些事件。
- 安全性任务： 守护进程还可以用于执行与系统安全性相关的任务，例如监控登录尝试、防火墙管理等。

举例：

一个常见的守护进程是cron，它负责周期性地执行预定的任务。另一个例子是sshd，用于处理远程登录请求。

总的来说，守护进程是系统中执行后台任务的重要组成部分，它们确保了系统的稳定性、可靠性和高效性。通过处理系统级别的任务，守护进程在很大程度上提升了计算机系统的整体性能和管理效果。