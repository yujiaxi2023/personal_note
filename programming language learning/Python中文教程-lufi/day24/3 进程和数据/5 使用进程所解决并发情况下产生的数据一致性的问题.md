每个进程都包含：代码段，数据集
读写是两个分开的操作
例如每一个代码都会去读到data=1，在多进程开始的阶段都是1
然后网速快的执行到下一步抢票代码的时候就会把data - 1获得0，这个过程因为读取到data=1的进程是多个，所以获得票的进程也会是多个

进程会共享内存，文件或者网络连接，因此，如果同时进行访问共享资源并进行写操作就会出现预想之外的操作结果

例如下面的进程，中间数据集都是去公共的位置读取数据
![[Pasted image 20240206172106.png]]

此时我们可以对共享数据库加锁，给这个所分配钥匙
这个锁是独立于进程之外的，每次进程访问的时候都需要先访问锁然后才能访问数据库
这样保证同时间内更改这个共享资源的进程只有一个

下面是实行代码
报错的话可以考虑给time.sleep的时间延长
```python
import json  
import time  
from multiprocessing import Process, Lock  
  
# 多进程同时打开操作同一个文件就会资源冲突导致报错  
# 执行文件，可以发现，只有1张余票，但是实际上有多个人买到票  
# 这就是多进程并发/并行带来的数据操作的过程中一致性问题，这个问题很严重  
def get_ticket(username):  
    """查询余票"""  
    # with open("ticket.txt", "r") as f:  
    #     data = json.load(f)    #     print(f"{username}查询余票：{data['count']}")  
    data = json.load(open("ticket.txt", "r"))  
    print(f"{username}查询余票：{data['count']}")  
  
def buy_ticket(username):  
    """购买车票"""  
    time.sleep(0.01) # 买票首先要读取数据，这个会耗费时间  
    # with open("ticket.txt", "r") as f:  
    #     data = json.load(f)    data = json.load(open("ticket.txt", "r"))  
    # 要买票必须是票存在，如果邮票就买票  
    if data["count"] > 0:  
        data["count"] -= 1 # 购买车票，余量减一  
        print(f"{username}成功购买车票")  
    else:  
        print(f"{username}购买车票失败")  
    time.sleep(0.01)  
    # with open("ticket.txt", "w") as f: # 不可以这么写，因为多进程下面无法对同一文件同时操作  
    #     # 这里代表对json文件进行多次读取，就自然会进行报错  
    #     json.dump(data, f)  
    json.dump(data, open("ticket.txt", "w"))  
  
def task(username, lock):  
    """购票流程"""  
    get_ticket(username)  
    # 给需要加锁的代码添加加锁和解锁的操作  
    lock.acquire() # 加锁  
    buy_ticket(username)  
    lock.release() # 解锁  
  
  
if __name__ == "__main__":  
    # 进程中创建锁  
    lock = Lock()  
    for i in range(10):  
        p = Process(target=task, args=(f"user-{i}", lock))  
        p.start()
```
然后添加进程锁需要在Process中添加上arg

acquire和release就是加锁解锁的代码,基于同步阻塞的方式运行的

如果lock加锁了之后的代码出现报错,不执行解锁过程
就可能产生问题,类似于一个人拿走了钥匙,别人就无法操作
这种就叫做死锁的情况.

工作中直接加锁不是很好
另一种方式
```python
with lock: # 内部原理是__enter__和__exit__方法 就会自动解锁的作用
	buy_ticket(username)
```

添加,修改,删除的操作就称为写操作,都需要进行加锁

锁的实现方式可以有很多, 可以基于全局数据, 也可以基于内存, 也可以基于文件, 或者网络. 但是所有的锁都是针对共享数据和资源的操作进行写操作的安全性操作.
