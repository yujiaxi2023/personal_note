### 当前进程 current_process
这个操作可以让我们在进程内存操作中获取当前进程的操作对象
```python
from multiprocessing import Process,current_process  
import os  
  
def watch():  
    p = current_process() # 通过这个方式可以拿到当前进程名字  
    print(f"当前进程名字：{p.name},当前进程id{p.pid}")  
    p.kill() # win下使用  
    # linux不可以使用kill  
    # linux下使用close，但是这个方法是异步非阻塞方法，所以后续代码还会执行，只是提前回收了这部分资源  
    # p.close()  
    # 使用exit容易出现僵尸进程，在主进程结束回收子进程之前子进程一直处在僵尸进程的状态  
    # 所以，可以使用当前进程对象进行关闭  
    for i in range(3):  
        print(f"进程{p.name}看电视。。。", os.getpid())  
        # 如果希望在进程内部获得当前基础南横的相关信息，或者进行关闭操作  
  
if __name__ == "__main__":  
    print("主进程", os.getpid())  
    # 创建子进程  
    # name声明进程名字  
    p = Process(target=watch, name="watch") # 在这里传不了当前对象  
    p.start()
```

### 锁
使用一个高铁的购票程序
有一个文件转换保存余票数量ticket.txt
```python
import json  
import time  
from multiprocessing import Process  
  
# 多进程同时打开操作同一个文件就会资源冲突导致报错  
# 执行文件，可以发现，只有1张余票，但是实际上有多个人买到票  
# 这就是多进程并发/并行带来的数据操作的过程中一致性问题，这个问题很严重  
def get_ticket(username):  
    """查询余票"""  
    # with open("ticket.txt", "r") as f:  
    #     data = json.load(f)    #     print(f"{username}查询余票：{data['count']}")  
    data = json.load(open("ticket.txt", "r"))  
    print(f"{username}查询余票：{data['count']}")  
  
def buy_ticket(username):  
    """购买车票"""  
    time.sleep(0.01) # 买票首先要读取数据，这个会耗费时间  
    # with open("ticket.txt", "r") as f:  
    #     data = json.load(f)    data = json.load(open("ticket.txt", "r"))  
    # 要买票必须是票存在，如果邮票就买票  
    if data["count"] > 0:  
        data["count"] -= 1 # 购买车票，余量减一  
        print(f"{username}成功购买车票")  
    else:  
        print(f"{username}购买车票失败")  
    time.sleep(0.01)  
    # with open("ticket.txt", "w") as f: # 不可以这么写，因为多进程下面无法对同一文件同时操作  
    #     # 这里代表对json文件进行多次读取，就自然会进行报错  
    #     json.dump(data, f)  
    json.dump(data, open("ticket.txt", "w"))  
  
def tasK(username):  
    """购票流程"""  
    get_ticket(username)  
    buy_ticket(username)  
  
  
if __name__ == "__main__":  
    for i in range(10):  
        p = Process(target=tasK, args=(f"user-{i}",))  
        p.start()
```
并发会导致一张票被多个人买票
这会导致数据出现安全性问题

