
要想要多个进程交替运行，操作系统必须对这些进程进行管理调度，这个调度不是随即进行的，是需要遵循一定的法则和算法，就是调度算法

- FCFS调度算法
先来先服务调度算法（FCFS）是一种最简单的调度算法，可以用于作业调度，也可以用于进程调度。FCFS算法有利于长作业（进程），不利于短作业（进行）。由此可以得知，本算法适合于CPU繁忙行作业，不利于IO繁忙作业

- SJF/SPF调度算法
短作业优先调度算法（SJF,SPF）是指对短作业或者短进程优先调度的算法，该算法既可以用于作业（进程）调度，但是对于长作业不利；不能保证紧迫性作业（进程）被及时处理；作业的长短只是被估算的，无法准确预测需要的CPU运行时间（原因有很多，例如程序中太多的if-else语句，分支很多，并且出现input，recv等类似的输入操作，因此无法预估所需时间），而且会导致“饥饿”现象（长作业一直得不到调度）

- RR调度算法
时间片轮转调度算法（Round Robin，RR）的基本思路是让每个进程在就绪队列中等待时间和享受服务的时间成比例。在时间片轮转中，将cpu处理时间分成固定大小的时间片，例如，几十毫秒甚至于几百毫秒。如果一个进程在被调度选中之后用完了系统规定的时间片，但是未完成要求的任务，则会自行释放自己占有的CPU而排列到就绪队列的末尾，等待下一次调度，同时，进程调度系统会调度当前就绪队列中的第一个进程。

轮转法中，时间片的长度选择非常重要，首先，时间片的长度选择会直接影响到系统的开销和响应时间。如果时间片长度过短，则调度程序抢占处理机的次数增多。这将使得进程上下文切换次数也大大增加，加重系统开销。如果时间片选择过长，例如，一个时间片就能保证就绪队列中所需执行时间最长的进程执行完毕，那么轮转法就变成了先来先服务算法。时间片的长度的选择是根据系统对响应时间的要求和就绪队列中允许的最大进程数来确定的。
在轮转法中，加入到就绪队列的进程有3种情况：
1. 分给它的时间片用完了，进程没有完成，就回到就绪队列的末尾等待下次调度
2. 分给进程的时间片未完成，但是因为请求I/O或者进程的互斥或者同步关系被阻塞。当阻塞解除之后就回到就绪队列
3. 新创建进程进入就绪队列

- MFQ调度算法
多级反馈队列调度算法（Multi-level Feedback Queue，MFQ），是属于上面几种算法的折中算法，是目前认为最公平/最优的算法。
所有进程进来之后，进行第一个队列的排队，会对第一个队列进行占用CPU的调度，如果完成就进行输出，如果第一队列没有完成任务，就放到第二队列中。比如第一队列就是每个进程0.01秒，然后进入到第二序列中，会分配更高的时间片资源，比如0.02秒，这个队列分配的资源更多，但是执行时间边长，如果执行完了就output，如果没有，就进入第三序列，如果这个时候进入了一个新的程序，那么涉及到一个点，执行的优先级：永远是第一序列先执行，接着以此类推。
以老教授运行一天的程序举例，比如说我的短作业其实增加了运行时间，多了有1个小时，但是因为长作业时间很长，所以感知不到。
![[Pasted image 20231210173954.png]]


## 并发，并行和串行

并行（Parallel），是多个任务在同一时间分别在各个CPU下执行，在多核CPU中才会有并行。
![[Pasted image 20231210174239.png]]

并发（Concurrent）是在资源有限（单核CPU）下，系统调度只能在同一时间执行一个任务，CPU的控制权在多个任务作业之间来回快速切换。看起来就像是执行了多个任务作业的幻觉。并发在单核和多核CPU都可以存在，并发实际上是串行效果
![[Pasted image 20231210174430.png]]

串行（Serial）是多个任务同一时间内CPU只能够执行一个任务作业，当第一个完成之后第二个进行
![[Pasted image 20231210174516.png]]

### 进程的状态

在实际开发中，往往任务作业的数量远远大于CPU的核数，所以在程序运行的过程中，由于操作系统被调度算法控制，程序会进行下面几个状态：就绪，运行和阻塞。

每一个任务都要进行就绪，运行，阻塞，退出才能算完整完成执行
首先需要进入就绪状态进入到就绪队列中，然后排队到自己后进行进程调度进到运行中，完成时间片后如果完成了就output并推出，如果遇到事件请求IO操作，就会进入到阻塞状态，那么就会重新进行就绪状态进行排队等待进程调度。
![[Pasted image 20231210174941.png]]

- 就绪状态（Ready），当进程已经分配到除了CPU以外的所有必要的资源，只要获得处理机就可以立即执行，这时候的进程状态称为就绪状态。
- 执行/运行状态（Running）当进程已经获得处理机，其程序正在处理及上执行，这时候进程是执行状态
- 阻塞状态（Blocked）正在执行的进程，由于等待某个事件发生而无法执行的时候，便放弃处理机而处于阻塞状态。引起阻塞的事件可以有很多种，例如，等待I/O完成，申请缓冲区不能满足，等待事件（信号）等。

```python
# 程序在开始运行之后，不是立刻开始执行代码，而是进入到就绪状态，等待操作系统调用  
import time # 程序运行状态  
  
print("程序开始运行") # 程序运行状态  
  
name = input(">:") # 这里遇到等待用户输入操作，会进入到程序阻塞状态  
# 用户输入之后是重新进入就绪状态而不是立即执行，需要等待操作系统的进程调度  
print(f"name{name}") # 运行  
time.sleep(5) # 事件阻塞  
# 重新进入就绪状态  
print("程序运行结束了") # 运行  
# 结束运行退出
```

只有在结束运行退出后才会释放系统资源，也就是回收掉进程的PID等内容

因为上面多个进程调度的原因，会呈现三种状态，也会带来了同步，异步，阻塞和非阻塞的概念