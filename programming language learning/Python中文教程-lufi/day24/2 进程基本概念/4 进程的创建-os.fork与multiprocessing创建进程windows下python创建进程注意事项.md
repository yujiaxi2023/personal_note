
python中实现多进程的操作有很多种方式，os模块的fork方法,multiprocessing模块，process模块，subprocess模块等，其中，multiprocess是python内置的一个操作,管理进程的包。之所以叫multi是因为这个包中几乎包含了和进程有关的所有子模块，大致分为四个部分：创建进程部分，进程同步部分，进程池部分，进程之间数据共享。

## 进程的创建os.fork

使用os.fork创建进程
fork有分叉，复制的意思

代码：
```python
import os  
  
if __name__ == '__main__':  
    # 通过fork创建一个子进程  
    w = 100  
    pid = os.fork() # 在子进程中pid=0，而在父进程中会pid大于0，因为是父进程中执行了fork，所以得到子进程的pid作为返回值  
    print(f'1. 当前进程PID： {os.getpid()}')  
    if pid == 0:  
        print(f"2. w={w},子进程PID={os.getpid()},当前子进程的父进程PID={os.getppid()}")  
    else:  
        print(f"3. 当前进程PID：{os.getpid()}, 创建一个子进程，PID={pid}")
```

这里os.fork的返回值可能是0或者是大于0
python主程序是主进程/父进程
os.fork之后是将主进程内存信息复制到新的进程中
数据集中会储存变量和pid
执行过程中，如果执行的是父进程，就会返回父进程的pid
但是os.fork复制出的程序并没有执行,所以PID就是0

os.fork的作用是把后边的代码复制到子进程中去
```python
import os  
  
if __name__ == '__main__':  
    # 通过fork创建一个子进程  
    w = 100 
    print(f'1. 当前进程PID： {os.getpid()}')  
    pid = os.fork() # 在子进程中pid=0，而在父进程中会pid大于0，因为是父进程中执行了fork，所以得到子进程的pid作为返回值  
 
    if pid == 0:  
        print(f"2. w={w},子进程PID={os.getpid()},当前子进程的父进程PID={os.getppid()}")  
    else:  
        print(f"3. 当前进程PID：{os.getpid()}, 创建一个子进程，PID={pid}")
```
在这里print这个代码并不是在os.fork创建的子进程中
所以不会执行这段print

上面一段代码的执行顺序显示
1.执行print,这个print是在os.fork创建到的进程中的,所以pid不是0
2.执行else条件的内容,当前进程的pid打印出来,然后打印出pid变量,也就是os.fork在的内存,是跟父进程不一样的一个新的内存区域
3.上边就是父进程执行结束,开始执行子进程
4.os后边有代码


![[Pasted image 20231223153955.png]]
主进程代码中的代码块和数据库会进行创建,然后因为主进程是执行的,所以主进程的执行块也存在并运行
在fork之后,会将代码块和数据集一并复制到新开的内存空间,也就是子进程中,子进程中会存在有同样的变量
这里进行复制是将数据集完全复制过去,然后代码段是只复制fork后边的代码

两个进程之间相互独立并且并发/并行
从fork运行之后,两个进程没有关系了
执行代码的时候会给父进程一个值,假设是12508,然后子进程默认不执行pid赋值是0
操作系统创建进程需要耗费一定资源,所以存在一个细微的时间延迟
总会先运行父进程代码
在创建子进程的时候,系统资源正在占用,但是父进程不会等待这个os.fork创建进程,所以会继续执行代码,这个时候就到了if条件了
这时候父进程的pid是12508,并不是0,所以会执行else条件的语句
然后子进程创建之后,需要进入就绪状态,然后执行

父进程:
写入w变量,打印当前进程id
向系统发送调用请求,请求创建新内存用来存放子进程
然后不停,立马进入到if循环,判断pid是什么,进入else循环
这时候父进程全部结束了

子进程:
执行os.fork后边的代码,
直接进入if判断,这时候pid=0,进入if条件
然后才打印2这句

进程是一个集合:
代码段
数据集
控制块

进程结束之后操作系统回收资源
子进程的相关资源是谁回收的?
可能是操作系统,也可能不是操作系统回收的资源
当主进程运行的代码结束之后,不会立刻进行资源回收,这时候会出于等待状态,等待子进程运行结束,当子进程运行结束之后,主进程就会对子进程的资源进行回收,主进程会进行系统调用,让操作系统回收子进程的资源,接着操作系统才会回收主进程资源.
当主进程运行代码结束之后,如果没有等待并回收子进程的资源,就会出现2种情况:
1. 操作系统会进行进程的扫描,查找到没有主进程管理的子进程,会被系统的init(pid=0)的进程进行几种管理,这个时候的子进程称为孤儿进程
2. 操作系统无法对子进程进行回收管理,无法被init(pid=0)的进程查看到,当这种子进程就属于僵尸进程
![[Pasted image 20231223160817.png]]


fork的实现是复制主进程的内存信息到子进程的创建方式,fork的本质是依赖于linux操作的fork系统调用来实现创建进程.但是在win下,没有fork系统调用,所以代码运行在win下面会报错
![[Pasted image 20231223161257.png]]
win种没有fork程序

常用方法
方法名            概述
os.fork()          创建子进程,复制一份主进程信息,创建要给子进程,依赖于linux
os.getpid()      获取当前进程的pid
os.getppid()    获取当前进程的父进程的pid



## multiprocessing创建

创建一个进程:
- 首先会从主进程中申请一块内存
- 然后创建代码块,数据集和控制块

通过Process这个类创建了一个进程内存空间:
- 创建的子进程有程序段,数据集和控制块
- 这里的程序段是target指定的一段
- 数据集是copy的主进程的数据集

在linux和macos下multiprocessing底层就是fork
multiprocessing做了一些优化,是完整将pid从主进程中复制
![[Pasted image 20231224170108.png]]
可以看到process是一样的
![[Pasted image 20231224182541.png]]
这里看到watch函数的id是不一样的,所以是存在不同的内存空间中
```python
import multiprocessing  
import os  
import time  
  
def watch():  
    # print("子进程的watch函数：", os.getpid())  
    print("子进程中的watch函数", id(watch))  
    for i in range(3):  
        print("看电视...", os.getpid())  
        time.sleep(1)  
  
if __name__ == '__main__':  
    print("主进程中的watch函数：", id(watch))  
    # 进程操作对象= multiprocessing.Process(target=任务)  
    # 任务是一个函数，也可以是一个方法  
    process = multiprocessing.Process(target=watch)  
    process.start() # 启动并创建进程
```

windows因为没有fork,所以创建进程操作是使用import导包实现的
是将父进程代码导入到子进程中实现,所以会自动执行导入模块的代码,就会进行报错
所以就是如果没有if语句的话,判断这是主程序执行文件,那么导入包的时候就会同时执行代码中包含的执行代码,所以就产生了矛盾,会不断开辟新的子进程,就不对了
![[Pasted image 20231224183313.png]]

socket翻译成中文时套接字，插座
socket可以理解是一种管道

进程在python中比较常用的
python开发效率高，运行效率很低
没法跟别的语言进行比较
其他都是编译型语言，而python是解释型语言

C/C++ java go rust对于多进程的使用是比较谨慎的
原因是：
在C/C++、Java、Go和Rust等编程语言中，对于多进程的使用需要相对谨慎，因为多进程的创建和管理涉及到较高的系统开销，可能会影响程序的效率。以下是这些语言在多进程使用方面需要谨慎考虑的一些因素：

1. 进程创建开销： 在这些语言中，创建一个新的进程通常需要较多的系统资源和时间。这包括分配新的进程空间、复制父进程的资源、加载新的程序映像等步骤。频繁创建和销毁进程可能会导致系统资源的浪费和性能下降。
2. 进程间通信开销： 不同进程之间的通信通常需要通过进程间通信（IPC）机制来实现，如管道、消息队列、共享内存等。这些机制可能会引入额外的开销和复杂性，特别是在数据传输量较大或频繁通信的情况下。
3. 竞态条件和同步问题： 多进程环境下，由于进程之间的独立性，可能会出现竞态条件和同步问题。需要使用同步机制（如信号量、互斥锁等）来确保进程间资源的正确共享和互斥访问，这增加了编程的复杂性和潜在的错误风险。
4. 上下文切换开销： 当系统在多个进程之间进行切换时，需要保存和恢复每个进程的执行状态，这会引入上下文切换的开销。频繁的上下文切换可能会导致系统的性能下降，特别是在CPU密集型的应用中。

资源管理和泄漏： 在多进程环境中，需要谨慎管理进程所使用的资源，如文件描述符、内存等。不正确的资源管理可能导致资源泄漏或者资源竞争，进而影响程序的稳定性和可靠性。

因此，尽管多进程提供了一种有效的并发模型，但在使用C/C++、Java、Go和Rust等语言时，需要仔细权衡多进程带来的开销和复杂性，确保其在特定场景下的适用性和效率。在某些情况下，可能会考虑使用线程（多线程）或者其他并发模型来替代多进程，以降低系统开销和提升性能。


编译型语言中进程使用比较谨慎，线程使用更加宽泛
python这种解释型语言中，线程的使用无法实现有效的提升并发性能

进程存在很多的不足：
- 单个进程在同一时间只能做一件事情，如果执行多个func需要集合函数才行
- 进程如果遇到阻塞，例如等待输入，进程就会挂起，即使有些进程不依赖于输入的数据也无法执行
- 操作系统在每个进程的创建，管理，切换回收等操作上，需要耗费一定的计算机资源，如果多任务场景下，多个进程调度比较频繁的话，CPU就会浪费很多资源在切换调度进程和进程的创建回收上面

进程是充分发挥CPU多核的特性
逻辑处理器是代表最大可能同时运行的任务数量
进程不能开太多，不然会减低CPU寿命
