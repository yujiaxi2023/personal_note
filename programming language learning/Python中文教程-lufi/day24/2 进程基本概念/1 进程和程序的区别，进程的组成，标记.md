### 什么是并发编程

是通过代码编程让计算机在一定时间内跑多个程序进行的编程操作，实现CPU执行多任务，并发编程就是充分利用cpu

多任务实现由下面3种方式：
- 进程：是操作系统资源分配和独立运行的最小单位
- 线程：是进程内一个任务执行独立单元，是任务调度和系统执行的最小单位
- 协程：用户态的轻量级线程，协程的调度完全由用户控制，主要为了单线程下的模拟多线程

一个程序可以由一到多个多进程，一个进程下可以是一到多个线程或者协程，一个线程下可以有一到多个协程。

## 进程

狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）
广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元

所以进程（process）就是被cpu运行起来的程序和相关资源的统称，是计算机程序关于某个数据几何上的一次运行活动，是系统进行资源分配和调度的最小单位

### 进程和程序的区别

程序是指令，数据和其组织形式的描述，进程是程序的实体。程序本身没有生命周期，只是储存在磁盘上的一些指令代码，程序一旦进行运行就是进程

如果一个程序内部进行了多个进程的创建管理，那cpu运行的时候就是多进程运行的。但是一般同一个程序只是进行单进程的运行状态。

在任务管理器中可以看到进程管理，可能会存在有父进程和子进程的模式
![[Pasted image 20231208205936.png]]

#### 进程的组成

进程一般是由程序段，数据集，程序控制块三个部分组成：

程序段：也叫指令集，进程执行过程中需要运行的代码段，是储存在内存中对应进程的程序段中

数据集：也叫数据段，进程执行过程中向操作系统申请分配的所需要使用的资源，程序运行的时候，使用与产生的运算数据，比如全局变量，局部变量等就存放在对应进程的数据集内。

控制块：也叫程序控制快（program control block，简称PCB）用于记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，是操作系统感知进程存在的唯一标志。创建进程，实质上是创建进程中的进程控制块，而销毁进程，实质上是回收进程中的进程控制块

运行一个程序的时候是创建了一个内存空间，分开了3个空间，
- 其中程序段空间存储程序代码，复制硬盘中的代码
- 一些函数全局变量局部变量，参数等放到数据集空间
- 程序运行的时候的时候会因为先来先服务算法 ，短服务优先算法，会有一个程序切换过程

如果我们老教授和研究生都有几个程序要进行运行
如果遇到时间片到了，或者IO阻塞，就会进行程序切换
这时候需要注意，我们程序切换的时候是会有记忆的，会执行上一次执行的位置
程序控制块一定要在内存中，PCB来对进程进行控制和管理
如果操作系统感知不到了控制块，那就比较麻烦了，比如孤儿进程，僵尸进程。
![[Pasted image 20231208214020.png]]

进程和进程之间分配的资源是相互独立的

#### 进程的标记

操作系统中每打开一个程序都会创建一个进程ID，就是PID（process identification），是进程运行的时候系统分配到，是操作系统用于分配，有的进程开启的快结束的快，所以有的就可能看不见，也可能是操作系统开机的时候执行的进程，并已经结束了。但是这个PID会一直在操作系统运行的时候就不断的增大

进程的管理也可以使用PID进行管理。当进程执行结束的时候，操作系统会回收进程相关的一切，包括PID，所以每次看到的PID都可能不一样

```python
import os, time  
  
if __name__ == "__main__":  
    for i in range(50):  
        time.sleep(1)  
        os.getpid()  
        print(i, os.getpid())
```

在windows下可以通过任务管理器通过详细信息来了解到进行的所有进程
在linux下进行查看的命令是
```
top # linux查看进行中的进程
ps aux | grep # 也可以查看进行中的进程
```

上面代码中，我们实际上使用了python解释器运行起来的，所以上面代码运行的时候os.getpid()实际上就是python解释器这个程序运行起来的时候，操作系统给到的进程和PID

pycharm程序，实际上也是一个进程，所以可以通过调用父级进程查看pid
```python
import os, time  
  
if __name__ == "__main__":  
    for i in range(50):  
        time.sleep(1)  
        os.getpid() # 获取当前进程的PID  
        os.getppid() # 获取当前进程的父级进程PID  
        print(i, os.getpid(), os.getppid())
```
1. 所以是pycharm调用了python解释器，实际上pycharm通过创建进程的方式来调用了python解释器
2. python解释器执行了python模块代码

在当前程序中，基于cmd命令，也就是终端来执行代码的时候，实际上的运行流程是：
1. cmd终端调用了python解释器，通过创建进程的方式调用python解释器
2. python解释器执行python模块代码



