首先要清楚，同步和异步是多个任务处理过程的**方式**或手段，而阻塞和非阻塞式多个任务处理过程某个任务的**等待状态** （往往是因为IO操作带来的阻塞，如网络IO或者文件IO）

注意：同步异步和阻塞非阻塞是两种不同的概念也并不冲突

| 概念 | 描述 |
| -- | -- |
| 同步（Synchronous）| 执行A任务的时候，当A任务产生结果后，B任务可以执行操作，意思是一个任务接着一个任务执行下来|
| 异步（Asynchronous）| 执行A任务时，当A任务进入等待状态后可以执行B任务，然后A任务等待状态消失后回来执行A任务的后续操作，意思时多个任务可以交替执行，如果B任务需要A任务的结果，也无需等待A任务执行结束。|
| 阻塞（Blocking）| 执行A任务的时候进入等待（挂起）状态，在这个等待（挂起）状态下CPU不能执行其他的任务操作，也就是CPU不工作了。|
| 非阻塞（Nonblocking）| 执行A任务的时候进入等待（挂起）状态，在这个等待（挂起）状态下，CPU可以执行其他的B任务操作，也就是CPU工作中。|

同步，异步和阻塞，非阻塞可以产生不同的组合，同步阻塞，同步非阻塞，异步阻塞，异步非阻塞

正常情况下，生成器，socketserver是异步代码，其他的都是同步代码（目前学到的内容）

![[Pasted image 20231211150508.png]]
这也是一种同步方式，虽然更换了线程，但是实际上还是同一时间CPU只执行了一个任务
![[Pasted image 20231211150550.png]]
这也是一个同步形式

当A需要B任务的一个结果的时候，在异步过程中，是两个同时进行的进程，通过时间片切换的方式来回由操作系统调用，当A中间需要由B来产生的一个结果的时候，那系统会让这个部分的内容挂起，然后在B执行完成之后得到结果之后，再将挂起的A任务进行执行
![[Pasted image 20231211150924.png]]
异步其实是两个任务根据时间片的方式交替运行，而同步其实就是一定要A执行完成才能执行B

1. 同步阻塞形式
就是执行多个任务的时候，一个接着一个执行，如果A任务出于等待（挂起）状态的时候，CPU也是等待这个挂起状态的结束，不能进行其他的操作。是几种组合里面效率最低的一种

举个例子：
假设有任务A，执行完A之后执行B，如果这时候A sleep了5秒钟，这时候B也会延长开始执行的时间
![[Pasted image 20231211151439.png]]

```python
import time  
  
def TaskA():  
    print("task A start")  
    time.sleep(10)  
    print("task A stop")  
  
def TaskB():  
    print("task B start")  
    time.sleep(5)  
    print("task B stop")  
  
if __name__ == "__main__":  
    queue = [TaskA, TaskB]  
    for task in queue:  
        task()
```

2. 异步阻塞形式
就是执行多个任务的时候，多个任务可以交替执行，但是任意的任务处于等待（挂起）状态的时候，CPU也老老实实的等待，不能切换到别的任务执行。如果没有一个任务等待状态，CPU就会交替运行。因为阻塞的情况出现了，所以这个组合根本无法发挥异步的效果，看起来和同步阻塞几乎没有区别。只要任意一个任务阻塞了，那CPU就会不工作。
```python
import multiprocessing  
import time  
  
def TaskA():  
    print("task A start")  
    time.sleep(0.1)  
    print("task A stop")  
  
def TaskB():  
    print("task B start")  
    time.sleep(0.1)  
    print("task B stop")  
  
  
if __name__ == "__main__":  
    a_process = multiprocessing.Process(target=TaskA)  
    b_process = multiprocessing.Process(target=TaskB)  
  
    queue = [a_process, b_process]  
    for process in queue:  
        process.start() # 启动进程，分配代码块，数据集，控制块  
        """  
        在打印的时候，会发现很多种组合情况发生  
        情况一：  
        task A start        
        task B start        
        task B stoptask A stop        
        情况二：  
        task B start        
        task A start        
        task A stop        
        task B stop        
        有这个效果其实就是并行并发导致的，几乎是同一时间段开始结束的AB进程          
        打印也属于IO，不交给CPU执行的  
        所以就会出现不同打印出来的结果可能会不一样  
        """  
        # 所以我们进行阻塞  
        process.join() # 加上这个就会形成异步阻塞  
        """  
        task A start        
        task A stop        
        task B start        
        task B stop        
        这时候我们会看到，阻塞了之后就会停止CPU，所以顺序就对了  
        """
```

3. 同步非阻塞式
就是执行多任务的时候，一个接着一个执行，如果A任务出于等待（挂起）状态的时候，CPU会切换到其他的任务B操作，而B任务操作过程中不会进入阻塞状态，当B任务操作结束之后，CPU切换回到A任务接着执行，知道A任务结束，CPU接着执行其他任务操作。
意思就是A执行的时候遇到阻塞的情况，跳到另一个任务B中，如果B不阻塞，并且B后边没有C任务排队，那么B执行结束之后才会回到A，前提是这时候的A已经脱离的阻塞状态，如果B后边跟着C排队，那A还需要继续等待C的执行完成才会返回到A的执行过程
![[Pasted image 20231211153612.png]]
```python
# 要模拟同步非阻塞模式，需要使用一个asyncio库的方式来写
import asyncio  
  
async def task_a():  
    print("Task A started")  
    await asyncio.sleep(2)  # 模拟任务 A 阻塞  
    print("Task A completed")  
  
async def task_b():  
    print("Task B started")  
    # await asyncio.sleep(1)  # 模拟任务 B 阻塞1秒更短时间 ABCBCA    # await asyncio.sleep(2)  # 模拟任务 B 阻塞2秒一样时间 就会是ABCABC  
    await asyncio.sleep(3)    # ABCCAB  
    print("Task B completed")  
  
async def task_c():  
    print("Task C started")  
    # await asyncio.sleep(1)  # 模拟任务 C 阻塞1秒更短时间  
    # await asyncio.sleep(2)  # 模拟任务 C 阻塞2秒一样时间  
    print("Task C completed")  
  
# async def main():  
#     # 同步非阻塞执行 A->B->C#     await task_a()  
#     await task_b()  
#     await task_c()  
  
async def main():  
    # 启动任务 A、B、C，而不等待它们完成  
    task_a_instance = task_a()  
    task_b_instance = task_b()  
    task_c_instance = task_c()  
  
    # 等待所有任务完成（可选）  
    await asyncio.gather(task_a_instance, task_b_instance, task_c_instance)  
  
# 运行异步程序  
asyncio.run(main())
```
这个库是编写asynchronous代码的库，允许在同一线程中处理多个任务，实现并发执行，不需要多线程或者多进程的复杂性
这里创建了3个异步函数，abc任务
await这里是模拟任务执行的时候阻塞过程。这里用异步函数进行模拟，而非是使用真正的同步阻塞模式，是我们使用了并发这个特殊的方法让执行流程类似于同步执行，因为是在同一线程下，并且我们执行了执行bc任务之前需要await等待a任务执行完成
这里我们在A中制定了一个阻塞进程，BC中不进行阻塞


4. 异步非阻塞形式
就是执行多个任务的时候，多个任务可以交替执行，当任意一个任务A出于等待（挂起）状态的时候，CPU就会切换到其他任务B操作中，当A任务等待（挂起）状态消失之后，CPU接着交替执行多个任务，异步非阻塞是我们追求的最完美的形式。

只要有一个程序在跑，CPU就会跑下去
```python
import multiprocessing  
import time  
  
def TaskA():  
    print("task A start")  
    time.sleep(2) # 模拟阻塞  
    print("task A stop")  
  
def TaskB():  
    print("task B start")  
    time.sleep(3) # 模拟阻塞  
    print("task B stop")  
  
def TaskC():  
    print("task C start")  
    print("task C stop")  
  
if __name__ == "__main__":  
    a_process = multiprocessing.Process(target=TaskA)  
    b_process = multiprocessing.Process(target=TaskB)  
    c_process = multiprocessing.Process(target=TaskC)  
  
    queue = [a_process, b_process, c_process]  
    for process in queue:  
        process.start() # 启动进程，分配代码块，数据集，控制块
```

在工作中，很多人会把同步和阻塞混淆，因为很多时候同步操作会以阻塞的形式表现出来，同理，异步并不是非阻塞，因为异步操作一般不会在真正的IO操作中阻塞

python中实现多进程操作有很多方式，os模块的fork方法，multiprocessing模块，process模块。

