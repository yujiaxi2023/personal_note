**第3组（3）**
- bin，十进制转二进制
- oct，十进制转八进制
- hex，十进制转十六进制

**第4组（2）**
- ord，获取字符对应的Unicode码点（十进制）
```python
# ord 获取字符对应的Unicode码点(十进制)  
v1 = ord("武")  
print(v1, hex(v1))
```

- chr，根据码点（十进制）获取对应字符
```python
# chr 根据码点(十进制)获取对应字符  
v1 = chr(12345)  
print(v1)
```

**第5组（9）**
- int
- float
- str,unicode编码储存
- bytes，unicode压缩utf-8编码或者gbk编码等
```python
v1 = "wupeiqi" # str类型

v2 = v1.encode("utf-8") # bytes类型

bytes(v1,encoding="utf-8")
```
- bool
- list
- dict
- tuple
- set

**第6组（10）
- len 计算一个值长度
- print 打印
- input
- open 打开文件
- type 获取数据类型
```python
v1 = "123"

if type(v1) == str:
	pass
else:
	pass
```
- range
```python
range(10)
```
- enumerate 既可以循环输出一个数据，又可以维护一个数值
```python
# enumerate  
v1 = ["wupeiqi", "alex", "root"]  
for item in enumerate(v1，1):  
    print(item)  
"""  
(1, 'wupeiqi')
(2, 'alex')
(3, 'root')
"""
```
代表取值的时候可以获得一个数值，简单来说是迭代过程中获得元素的索引和值
enumerate的返回值是一个可迭代的生成器对象，生成器会包含索引和值的元组，每次迭代的时候都会返回一个元组
- id
- hash
```python
v1 = hash("wupeiqi")
```
- help
```python
import random

help(random)
help(str)
```
pycharm一般就ctrl去看了，不需要
终端会使用
- zip
```python
# zip  
v1 = [11,22,33,44,55,66]  
v2 = [55,66,77,88]  
v3 = [10,20,30,40,50]  
  
result = zip(v1,v2,v3) # 将列表中的第n个元素集结起来  
# [11,33,10][22,66,20]  
print(result) # <zip object at 0x0000015677523DC0>
for item in result:  
    print(item)  
"""  
(11, 55, 10)  
(22, 66, 20)  
(33, 77, 30)  
(44, 88, 40)  
后边无法对应的数据就不会显示了,储存方式是列表里面套一个列表  
不会再内存中直接创建一个列表，而是获得一个迭代器，但是迭代器名字是zip
只有当循环或者next的时候可以取出来
"""
```

- callable，是否可执行
```python
# callable 是否可执行,后边是否可以加括号  
v1 = "wupeiqi"  
v2 = lambda x: x  
def v3():  
    pass  
  
print(callable(v1)) # False  
print(callable(v2)) # True  
print(callable(v3)) # True
```

- sorted 排序

倒叙进行排序
```python
v1 = sorted([101,221,33,44,55],reverse=True)  
v1.sort(reverse=True)  
  
print(v1)
```
sorted是函数，sort是列表内部提供的功能
需要sorted是因为字典和元组是没有这个内置功能

```python
# sorted 排序  
info = {  
    "wupeiqi": {  
        "id": 10,  
        "age": 119  
    },  
    "root": {  
        "id": 20,  
        "age": 29  
    },  
    "seven": {  
        "id": 9,  
        "age": 9  
    },  
    "admin": {  
        "id": 11,  
        "age": 139  
    }  
}  

v1 = sorted(info) # 只会给我key的排序

# 获得字典里面的元素进行排序
# .item会获得键值并形成一个一个的元组
# (wupeiqi,{...})
# (root,{...})
# (seven,{...})
# key就是循环每个元素
result = sorted(info.items(),key=lambda x: x[1]["id"])  
print(result)
```
解释一下sorted中的流程：
- 首先info.item()会获得一系列的元组
- key参数需要传入一个函数
- 这里设计的函数传入参数是item提取出来的元组的列表，并循环
- 首先获得的是元组的第二个元素，也就是值对应的字典
- 因为lambda函数返回值是后边的函数体，所以需要提取出id对应的值
- 就返回了一个个id对应的值，一边循环一边排序