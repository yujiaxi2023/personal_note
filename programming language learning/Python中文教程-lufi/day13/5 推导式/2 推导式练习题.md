```python
# 1. 去除列表中每个元素的.mp4后缀  
data_list = [  
    '1-5 编译器和解释器.mp4',  
    '1-17 今日作业.mp4',  
    '1-9 python解释器种类',  
    '1-16 今日总结.mp4',  
    '1-2 课堂笔记的创建.mp4'  
]  
  
result = []  
for item in data_list:  
    result.append(item.rsplit(".",1)[0])  
  
result_comprehensions = [item.rsplit(".",1)[0] for item in data_list]  
  
# 2. 将字典中的元素按照 键值 格式化，并最终使用；连接起来  
info = {  
    "name":"wupeiqi",  
    "email":"xxx@mail.com",  
    "gender":"male"  
}  
  
data_list = []  
for key,value in info.items():  
    temp = f"{key}-{value}"  
    data_list.append(temp)  
result = ";".join(data_list)  
print(result)  
  
result = ";".join([f"{k}-{v}" for k,v in info.items()])  
print(result)  
  
  
# 3. 将字典按照键从小到达排序，按照如下格式拼接起来（微信支付api内部处理需求）  
info = {  
    "sign_type": "MD5",  
    "out_refund_no": "12323",  
    "appid": "wx55cca0b94f723dc7",  
    "mch_id": "1526049051",  
    "out_trade_on": "ffff",  
    "nonce_str": "sdfdffd",  
    "total_fee": 9901,  
    "refund_fee": 10000  
}  
  
# 按照键大小排序  
# (sign_type,MD5)  
result = sorted(info.items(),key=lambda x:x[0])  
print(result)  
  
# 使用=拼接 然后再用&连接  
result = "&".join([f"{k}={v}" for k,v in result])  
print(result)  
  
# 可以全部强行写成一行有点长  
result = "&".join([f"{k}={v}" for k,v in sorted(info.items(),key=lambda x:x[0])])  
  
# 4. 看代码写结果  
def func():  
    print(123)  
  
data_list = [func for i in range(10)]  
print(data_list)  
"""  
全局作用域中放了一个函数，但是因为没有执行，所以内部的代码一定不执行  
"""  
# 下面这个例子使用lambda是一样的  
data_list = [lambda: 100 for i in range(10)]  
print(data_list) # 这个函数只有返回值100，而且并没有传参，也没有执行，只是这个函数名重复10次  
  
# 5. 看代码写结果  
def func(num):  
    return num + 100  
  
data_list = [func(i) for i in range(10)] # 函数执行了所以是return值10次储存在list中  
print(data_list)  
data_list = [(lambda i: i+100)(i) for i in range(10)] # 这里没有执行函数，所以还是一个内存地址  
print(data_list)  
  
  
# 6. 看代码写结果（执行出错，是为了理解执行过程）  
def func(x):  
    # return x + i  
    return x + 1  
  
data_list = [func for i in range(10)] # [函数，函数，···] 函数没有执行  
# 内部for循环执行完了i = 9  
  
val = data_list[0](100)  
# 取第1个func函数，这里面返回值是100+i，如果可以执行是100+9  
# 但是无法执行，因为说i是没有定义  
# 因为列表推导式中循环是属于列表推导式这个作用域的，所以i是储存在这个作用域中的  
# 所以全局作用域里面没有i  
print(val)  
  
# 7. 看代码写结果  
data_list = [lambda x: x+i for i in range(10)]  
# 创建函数lambda，创建的函数体不执行  
# 循环执行完了 i = 9 列表是包含函数对象  
# 因为lambda函数是在列表作用域中定义的，所以跟i是在同一作用域  
# 执行lambda函数的时候作用域是在列表作用域中执行，可以调用i，就不会报错  
val = data_list[0](100)  
print(val)
```