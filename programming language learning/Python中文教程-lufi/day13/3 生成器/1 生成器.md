生成器是由函数 + yield关键字创造出来的写法，在特定情况下，可以帮助我们节省内存

- 生成器函数，在函数中由yield存在的时候，这个函数就是生产生成器函数
```python
def func():  
    print(111)  
    yield 1  
  
# 生成器函数判断的唯一标准就是有没有yield,而函数中可以由多个yield  
def func_1():  
    print(111)  
    yield 1  
  
    print(222)  
    yield 2  
  
    print(333)  
    yield 3  
  
    print(444)
```


```python
def func():  
    print(123)  
    yield 1234  
  
# 执行生成器函数,函数体默认不会被执行  
v1 = func()  
print(v1) # 返回一个生成器对象 <generator object func at 0x0000019784A65350>
```


```python
def func():  
    print(123)  
    yield 1234  
    print(456)  
    yield 666  
    print(789)  
    yield 999  
    # return None 程序就会报错，生成器中代码执行完毕
  
# 执行生成器函数,函数体默认不会被执行  
v1 = func()  
print(v1) # 返回一个生成器对象 <generator object func at 0x0000019784A65350>  
next(v1) # next里面放生成器对象,将进入生成器函数,并执行其中的代码 123# 这里遇到了yield就停止运行了,中止运行  
n1 = next(v1) # yield后边的值会返还给n1,同时会记录返还时候的位置  
print(n1)  
# next里面放生成器对象,进入生成器函数执行代码,从上次yield返回位置继续向下  
# 执行了n2 的时候已经执行到789了  
n2 = next(v1)  
print(n2)  
# 这个时候继续执行,会报错StopIteration  
n3 = next(v1)  
print(n3)
```




```python
def func():  
    print(123)  
    yield 1234  
    print(456)  
    yield 666  
    print(789)  
    yield 999  
  
# 一般情况下这么使用  
data = func() # 生成器对象,并不是执行函数  
# 基于for循环执行生成器对象就不会报错,本质上内部就是执行next命令  
for item in data:  
    # next(data)  
    print(item)
```

