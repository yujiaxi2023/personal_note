程序开发过程中，经常会出现一些错误，或者在懒得做判断的时候，可以选择用异常处理来做

```python
import requests

while True:
    url = input("è¯·è¾å¥è¦ä¸è½½ç½é¡µå°åï¼")
    res = requests.get(url=url)
    with open('content.txt', mode='wb') as f:
        f.write(res.content)
```

上面代码在正常情况下可以运行，但是如果网络出现问题，程序就会报错说无法正常执行

```python
try:  
    res = requests.get(url=url)  
except Exception as e:  
    # 代码块，上述代码无法执行  
    break  
print("end")
```

应用场景
```python
# 应用场景1  
import requests  
  
while True:  
    url = input("请输入下载网址")  
  
    try:  
        res = requests.get(url=url)  
    except Exception as e:  
        print("请求失败，原因是{}".format(str(e)))  
        continue  
  
    with open('content.txt', mode='wb') as f:  
        f.write(res.content)  
  
  
# 应用场景2  
num1 = input("请输入数字")  
num2 = input("请输入数字")  
try:  
    num1 = int(num1)  
    num2 = int(num2)  
    result = num1 + num2  
    print(result)  
except Exception as e:  
    print("输入错误")
```

以后常见的应用场景是：
- 调用微信的API实现微信消息的推送，微信支付等
- 支付宝支付，视频播放等
- 数据库 或者 redis连接和操作
- 调用第三方视频播放的功能，由第三方的程序出现问题导致的出错

异常处理的基本格式
```python
try:
	# 逻辑代码
except Exception as e:
	# try中代码如果有异常，那么这个代码块中的代码会执行
```

```python
try:
	# 逻辑代码
except Exception as e:
	# try中代码如果有异常，则这个代码块中的代码执行
finally:
	# try中的代码无论是否报错，finally中的代码都会执行，一般用于释放资源
print("end")

"""
try:
	file_object = open('xxx.log')
	# ....
except Exception as e:
	# 异常处理
finally:
	file_object.close() # try中没有异常，最后执行finally关闭文件，try中有异常，执行except中的逻辑，最后执行finally关闭文件
"""
```

### 异常细分

```python
import requests  
  
while True:  
    url = input("请输入下载网址")  
  
    try:  
        res = requests.get(url=url)  
    except Exception as e:  
        print("下载失败，原因是{}".format(str(e)))  
        continue  
  
    with open('content.txt', mode='wb') as f:  
        f.write(res.content)
```

之前只是简单的捕获了异常，出现异常就统一提示信息即可，如果想要对异常进行更加细致的异常处理，可以这样做

```python
import requests  
from requests import exceptions  
  
while True:  
    url = input("请输入下载网址")  
    try:  
        res = requests.get(url=url)  
        print(res)  
    except exceptions.MissingSchema as e:  
        print("URL架构不存在")  
    except exceptions.InvalidSchema as e:  
        print("URL架构错误")  
    except exceptions.InvalidURL as e:  
        print("URL地址格式错误")  
    except exceptions.ConnectionError as e:  
        print("网络连接错误")  
    except Exception as e:  
        print("代码出现错误", e)
```

基本格式

```python
try:
    # 逻辑代码
    pass

except KeyError as e:
    # 小兵，只捕获了try代码中发现了键不存在的异常，例如：去字典info_dict['n1']中获取数据的时候，键不存在
    print("KeyError")

except ValueError as e:
    # 小兵，只捕获try代码中发现了值相关错误，例如：把字符串转整形 int('whaldf')
    print("ValueError")

except Exception as e:
    # 王者，处理上面except捕获不了的错误（可以捕获所有的错误）
    print("Exception")
```


python中内置了很多细分的错误可以选择

```python
常见异常
"""
AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x  
IOError 输入/输出异常；基本上是无法打开文件  
ImportError 无法引入模块或包；基本上是路径问题或名称错误  
IndentationError 语法错误（的子类） ；代码没有正确对齐  
IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问n x[5]  
KeyError 试图访问字典里不存在的键 inf['xx']KeyboardInterrupt Ctrl+C被按下  
NameError 使用一个还未被赋予对象的变量  
SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）  
TypeError 传入对象类型与要求的不符合  
UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，  
导致你以为正在访问它  
ValueError 传入一个调用者不期望的值，即使值的类型是正确的
"""

更多异常：  
"""  
ArithmeticError  
AssertionError  
AttributeError  
BaseException  
BufferError  
BytesWarning  
DeprecationWarning  
EnvironmentError  
EOFError  
Exception  
FloatingPointError  
FutureWarning  
GeneratorExit  
ImportError  
ImportWarning  
IndentationError  
IndexError  
IOError  
KeyboardInterrupt  
KeyError  
LookupError  
MemoryError  
NameError  
NotImplementedError  
OSError  
OverflowError  
PendingDeprecationWarning  
ReferenceError  
RuntimeError  
RuntimeWarning  
StandardError  
StopIteration  
SyntaxError  
SyntaxWarning  
SystemError  
SystemExit  
TabError  
TypeError  
UnboundLocalError  
UnicodeDecodeError  
UnicodeEncodeError  
UnicodeError  
UnicodeTranslateError  
UnicodeWarning  
UserWarning  
ValueError  
Warning  
ZeroDivisionError  
"""
```


### 自定义异常&抛出异常

上面都是python内置的异常，只有遇到特定的错误的时候会抛出相应异常
执行过程中报错就是这种类型

其实在开发过程中可以自定义异常
```python
class MyException(Exception):  
    pass  
  
try:  
    pass  
except MyException as e:  
    print("MyException异常被触发了", e)  
except Exception as e:  
    print("Exception", e)
```

上述代码中在except中定义了捕获MyException异常，但他永远不会被触发。因为默认的那些异常都有特定的触发条件，例如：索引不存在，键不存在会触发的IncexError和KeyError异常

如果要触发自定义的异常，就需要使用：`raise MyException()`类实现

```python
class MyException(Exception):  
    pass  
  
try:  
    # 。。。  
    raise MyException()    # 。。。  
except MyException as e:  
    print("MyException异常被触发了", e)  
except Exception as e:  
    print("Exception", e)
```

```python
class MyException(Exception):  
    def __init__(self, msg, *args, **kwargs):  
        super().__init__(*args, **kwargs)  
        self.msg = msg  
  
  
try:  
    raise MyException("xxx失败了")  
except MyException as e:  
    print("MyException异常被触发了", e.msg)  
except Exception as e:  
    print("Exception", e)
```

```python
class MyException(Exception):  
    title = "请求错误"  
  
  
try:  
    raise MyException()  
except MyException as e:  
    print("MyException异常被触发了", e.title)  
except Exception as e:  
    print("Exception", e)
```

1. 为啥需要自定义异常？- 提高代码的可读性和可维护性。 - 可以创建更具体的错误类型，帮助更精确的处理错误
2. 如何创建自定义异常？ - 自定义异常通常通过继承Exception类或者子类来创建。通常包含一个初始化方法`__init__`，用于设置异常信息
```python
class MyCustomError(Exception):
	def __init__(self, message):
		self.message = message
```

在 Python 中，将一个类定义为异常类的关键不在于它存储了哪些变量，而在于它是否继承自 Exception 类或其子类。自定义异常的名称“自定义”意味着你可以根据自己的需求创建一个特定的异常类型，而不是仅仅使用 Python 内置的异常类型。这样做有几个优点：

明确性和可读性：通过创建一个具有描述性名称的自定义异常（如 MyCustomError），代码的可读性会提高，因为异常类型本身就能提供关于出错原因的信息。

灵活性：你可以在自定义异常中添加任何你需要的属性或方法。在你的例子中，通过在初始化方法中存储一个 message 变量，你可以为这个异常提供更详细的错误描述。但这不是限制，你可以添加更多的属性或方法以适应你的需求。

特定于应用的错误处理：使用自定义异常允许你编写特定于应用的错误处理代码。这意味着当这个异常被触发时，你可以有针对性地捕获和处理它，而不是依赖于更广泛的、可能不完全适用的内置异常。

因此，自定义异常的“自定义”部分主要体现在你可以根据自己的需求创建异常，并通过继承 Exception 类将其作为一个合法的异常类型来使用。


抛出异常

1. 如何抛出异常？ - 使用raise关键字抛出异常。- 可以是内置异常，如ValueError，TypeError或者自定义异常
```python
def some_function(value):
	if not value:
		raise ValueError("Value cannot be empty")
```

2. 何时抛出异常？ - 当函数的某个条件不满足的时候，例如无效的参数值或者无法执行的操作。 - 当需要通知调用者某个错误发生的时候。

示例：
```python
class MyCustomError(Exception):
    def __init__(self, message):
        self.message = message

def divide_numbers(x, y):
    if y == 0:
        raise MyCustomError("Cannot divide by zero")
    return x / y

try:
    result = divide_numbers(10, 0)
except MyCustomError as e:
    print(f"An error occurred: {e.message}")
```
这个示例 中，创建了一个自定义异常，并在divide numbers函数中使用它来检查除数是否是0，如果是0，则抛出异常。调用函数的时候，使用try和except来捕获异常

是的，你的理解是正确的。在 Python 中，当使用 raise 关键字抛出异常时，实际上是创建了异常类的一个实例。这个实例在创建时可以接受一些参数，这些参数通常用于提供有关异常的更多详细信息。

在你的例子中，当 y == 0 时，你创建了一个 MyCustomError 的实例并抛出，实例化时传入的参数 message 是 "Cannot divide by zero"。这个 message 参数在 MyCustomError 类的 __init__ 方法中被接收并存储为该实例的属性。
```python
raise MyCustomError("Cannot divide by zero")
```

然后，当你在调用 divide_numbers(10, 0) 函数时，由于 y 等于 0，这个异常被抛出。在 try/except 块中，你捕获了这个异常，并打印出了异常信息，这个信息就是你在抛出异常时传入的 "Cannot divide by zero"。

```python
try:
    result = divide_numbers(10, 0)
except MyCustomError as e:
    print(f"An error occurred: {e.message}")
```

总的来说，raise 允许你创建并抛出一个异常实例，你可以通过在实例化异常时传入参数来提供有关异常的详细信息，然后在捕获异常时访问这些信息。

#### 稍微复杂一些的用法

在 Python 中，自定义异常可以从最基本的只包含 __init__ 方法到更复杂的包含多个方法和属性的形式。虽然一个简单的 __init__ 方法，其中只定义了一个用来存储错误消息的变量，对于许多情况来说已经足够了，但是确实还有更复杂的用法。下面是一些可能的扩展：

定义额外的方法和属性：你可以在自定义异常类中定义额外的方法和属性。例如，你可以添加一个方法来格式化错误消息，或者定义多个属性来存储错误的不同方面。

重写内置方法：可以重写标准异常类的内置方法，比如 __str__ 和 __repr__，来改变异常的字符串表示。这在打印或记录异常信息时特别有用。

支持错误代码：你可以在自定义异常中添加错误代码，这对于那些需要根据错误类型做出不同响应的情况很有帮助。

集成多个异常：有时候，你的自定义异常可能需要基于多个不同的异常来触发。在这种情况下，可以在自定义异常中集成这些不同的异常信息。

上下文管理：你可以为异常类添加上下文管理功能，这样在异常发生时可以执行一些清理工作或其他必要的操作。

链式异常：在 Python 3 中，可以使用 raise ... from ... 语法来链接异常，这样可以保留原始异常的上下文，同时抛出一个新的异常。

下面是一个稍微复杂一些的自定义异常的例子：
```python
class MyComplexError(Exception):
    def __init__(self, message, code):
        super().__init__(message)
        self.code = code

    def __str__(self):
        return f"{self.__class__.__name__}: [Error Code: {self.code}] {self.args[0]}"

# 使用这个异常
try:
    raise MyComplexError("An error occurred", 500)
except MyComplexError as e:
    print(str(e))
```
在这个例子中，MyComplexError 不仅包含了错误消息，还包含了一个错误代码，并且重写了 `__str__ `方法来定制异常信息的格式。

**解释上面代码**
1. 初始化方法`__init__` 
```python
def __init__(self, message, code):
	super().__init__(message):
	self.code = code
```
这个方法是类的构造函数，接收两个参数：message和code，message用于储存错误消息，并且调用super方法将message传入父类Exception中**解释为什么是是传入父类呢？** 
super方法本来是调用父类的方法，比如父类的初始化方法，因为Exception类中接收一个或者多个参数，**这里是关键**：
- 当你调用super方法的时候，实际上是将message传入到Exception类的构造函数，这意味着这个错误消息会被Exception类处理并储存
- Exception类内部使用一个args的元组储存这些参数，message会进入到这个元组中
- 标准库中没有定义message属性，但是因为传递给了args元组，所以访问的时候可以通过`args[0]`来访问这个传递给异常的第一个参数。

2. 字符串表示方法`__str__`
```python
def __str__(self):
	return f"{self.__class__.__name__}: [Error Code: {self.code}] {self.args[0]}
```
这个方法定义了异常对象的字符串表示，当打印记录这个异常的时候，会显示类名，错误代码和错误消息，(每个类都会继承object类)，这里面args是父类Exception中继承的属性，储存了传递给异常的第一个参数，这里是message

最后是抛出异常，如果异常出错会显示：
```
MyComplexError: [Error Code: 500] An error occurred
```



案例1 你我合作协同开发，你调用我写的方法

- 我定义了一个函数
```python
import re  
  
class EmailValidError(Exception):  
    title = "邮箱格式错误"  
  
  
class ContentRequiredError(Exception):  
    title = "文本不能为空错误"  
  
  
def send_email(email, content):  
    if not re.match("\w+@live.com", email):  
        raise EmailValidError()  
        if len(content) == 0:  
            raise ContentRequiredError()  
    # 发送邮件代码...  
    # ...
```

- 你调用我写的函数
```python
import re  
  
class EmailValidError(Exception):  
    title = "邮箱格式错误"  
  
  
class ContentRequiredError(Exception):  
    title = "文本不能为空错误"  
  
  
def send_email(email, content):  
    if not re.match("\w+@live.com", email):  
        raise EmailValidError()  
        if len(content) == 0:  
            raise ContentRequiredError()  
    # 发送邮件代码...  
    # ...  
  
def execute():  
    # 其他代码  
    # ...  
  
    try:  
        send_email(...)  
  
except EmailValidError as e:  
pass  
except ContentRequiredError as e:  
pass  
except Exception as e:  
print("发送失败")  
  
execute()  
  
# 提示：如果想要写的简单一点，其实只写一个Exception捕获错误就可以了。
```


案例二：框架内部定义好，遇到什么样的错误都会触发不同的异常

```python
import requests  
from requests import exceptions  
  
while True:  
    url = input("请输入要下载网页地址：")  
    try:        res = requests.get(url=url)        print(res)    except exceptions.MissingSchema as e:  
        print("URL架构不存在")  
    except exceptions.InvalidSchema as e:        print("URL架构错误")  
    except exceptions.InvalidURL as e:        print("URL地址格式错误")  
    except exceptions.ConnectionError as e:        print("网络连接错误")  
    except Exception as e:        print("代码出现错误", e)  
        # 提示：如果想要写的简单一点，其实只写一个Exception捕获错误就可以了。
```

案例三：按照规定去触发指定的异常，每种异常都具备特殊的含义
![[Pasted image 20231110232940.png]]


### 特殊的finally

```python
try:  
    # 逻辑代码  
except Exception as e:  
    # try中的代码如果有异常，则此代码块中的代码会执行。  
finally:  
    # try中的代码无论是否报错，finally中的代码都会执行，一般用于释放资源。  
  
print("end")
```

当在函数或者方法中定义异常处理的代码时候，要特别注意finally和return

```python
def func():  
    try:  
        return 123  
    except Exception as e:  
        pass  
    finally:  
        print(666)  
  
  
func()
```

在try或者except中即使定义了return，最后也会执行finally中的代码


## 练习题

1. 补充代码实现捕获程序中的错误。  
  
```python  
# 迭代器  
class IterRange(object):  
    def __init__(self, num):  
        self.num = num  
        self.counter = -1  
  
    def __iter__(self):  
        return self  
  
    def __next__(self):  
        self.counter += 1  
        if self.counter == self.num:  
            raise StopIteration()  
        return self.counter  
  
  
obj = IterRange(20)  
  
while True:  
    try:  
        ele = next(obj)  
    except StopIteration as e:  
        print("数据获取完毕")  
	    break  
	print(ele)       
```  


1. 补充代码实现捕获程序中的错误。  
  
```python  
class IterRange(object):  
    def __init__(self, num):  
        self.num = num  
        self.counter = -1  
  
    def __iter__(self):  
        return self  
  
    def __next__(self):  
        self.counter += 1  
        if self.counter == self.num:  
            raise StopIteration()  
        return self.counter  
  
  
class Xrange(object):  
    def __init__(self, max_num):  
        self.max_num = max_num  
  
    def __iter__(self):  
        return IterRange(self.max_num)  
  
  
data_object = Xrange(100)  
obj_iter = data_object.__iter__()  
  
while True:  
    try:  
        ele = next(obj_iter)  
    except StopIteration as e:  
        print("数据获取完毕")  
        break  
    print(ele)
```  


1. 补充代码实现捕获程序中的错误。  
  
```python  
def func():  
    yield 1  
    yield 2  
    yield 3  
  
  
gen = func()  
while True:  
    try:  
        ele = next(gen)  
    except StopIteration as e:  
        print("数据获取完毕")  
        break  
    print(ele)
```  


1. 补充代码实现捕获程序中的错误。（注意：本案例用于练习，在真是开发中对于这种情况建议还是自己做判断处理，不要用异常）  
  
```python  
num = int("武沛齐")  
```  
```python  
try:  
   num = int("武沛齐")  
except ValueError as e:  
   print("转换失败")
```  
1. 补充代码实现捕获程序中的错误。（注意：本案例用于练习，在真是开发中对于这种情况建议还是自己做判断处理，不要用异常）  

```python  
data = [11,22,33,44,55]  
data[1000]  
```  
```python  
try:  
    data = [11,22,33,44,55]  
    data[1000]  
except IndexError as e:  
    print("转换失败")
```  
     
6. 补充代码实现捕获程序中的错误。（注意：本案例用于练习，在真是开发中对于这种情况建议还是自己做判断处理，不要用异常）  
  
```python  
data = {"k1":123,"k2":456}  
data["xxxx"]  
```  
```python  
try:  
    data = {"k1": 123, "k2": 456}  
    data["xxxx"]  
except KeyError as e:  
    print("转换失败")
```  

1. 分析代码，写结果  
  
```python  
class MyDict(dict):  
  
    def __getitem__(self, item):  
        # try:  
        #     return super().__getitem__(item)  # KeyError        # except KeyError as e:        #     return None        return super().__getitem__(item)  
  
  
info = MyDict()  
info['name'] = "武沛齐"  
info['wx'] = "wupeiq666"  
  
print(info['wx'])  # info['wx']  -> __getitem__  
print(info['email'])  # info['email']  -> __getitem__ 这里就是key不存在字典中会触发error、  
# 如果注释掉try，就会发生报错，如果有try就不会报错，而是返回None
```  


1. 看代码写结果  
  
```python  
def run(handler):  
    try:  
        num = handler()  
        print(num)  
        return "成功"  
    except Exception as e:  
        return "错误"  
    finally:  
        print("END")  
  
    print("结束")  
  
  
res = run(lambda: 123)  
res1 = run(111)  
print(res)  
print(res1) 
```  
```python  
>>> 123  
>>> END   
>>> END
>>> 成功  
>>> 错误
```  
```python  
def func():  
    print(666)  
    return "成功"  
  
  
def run(handler):  
    try:  
        num = handler()  
        print(num)  
        return func()  
    except Exception as e:  
        return "错误"  
    finally:  
        print("END")  
  
    print("结束")  
  
  
res = run(lambda: 123)  
print(res) 
```  
```python  
>>> 123  
>>> 666   
>>> END   
>>> 成功  
```

