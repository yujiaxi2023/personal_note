计算机底层本质都是二进制，我们平时在计算机中做到很多操作底层都会转换为二进制的操作，位运算就是对二进制的操作

- & ， 与 （都为1）
```python
a = 60 # 60 = 0011 1100
b = 13 # 13 = 0000 1101

c = a & b # 12 = 0000 1100
```
与运算是将输入数据转换为二进制然后位和位进行逐个比较，如果两个位都为1，得到的结果就是1

- | ， 或（只要有一个为1）
```python
a = 60 # 60 = 0011 1100
b = 13 # 13 = 0000 1101

c = a | b # 61 = 0011 1101
```

- ^，异或（值不同）
```python
a = 60 # 60 = 0011 1100
b = 13 # 13 = 0000 1101

c = a ^ b # 49 = 0011 0001
```
两个值在二进制中对应的位的值不一样就取1

- ~ ， 取反
```python
a = 60 # 60 = 0011 1100

c = ~a; # -61 = 1100 0011
```
在二进制上取反换算成十进制

- <<，左移动
```python
a = 60 # 60 = 0011 1100
c = a << 2; # 240 = 1111 0000
```
变化过程是后边添加两个0，前面用来补位的0就没有必要存在了

- >>， 右移动
```python
a = 60 # 60 = 0011 1100
c = a >> 2; # 15 = 0000 1111
```
变化过程是左边添加两个0

**应用场景**
计算机底层和网络传输底层
- 计算2的n次方
```python
2**0 1<<0 1    1
2**1 1<<1 10   2
2**2 1<<2 100  4
2**3 1<<3 1000 8
```

- 计算一个数的一半
```python
v1 = 10 >> 1
print(v1) # 值为5

v2 = 20 >> 1
print(v2) # 值为10
```
计算机计算就是向右移动一位就是一半

- 网络传输数据，文件太大还未能传输完（websocket源码为例）
在传输数据过程中需要提示 对方还没有传输完，中间需要有标记说明还没有传输完成
二进制中是1就代表这段传完了，是0代表这段没传完
![[Pasted image 20230616170036.png]]
```python
# 例如：接收到的第一个字节的值为245（11110101），让v的二进制和1000 0000做&运算

v = 245 # 245 11110101
		# 128 10000000

data = v & 128
if data == 0:
	print("还有数据")
else:
	print("已完毕")
```
跟128做与运算，结果要么是0，要么是128，如果是0代表v的值第一个是0，如果是128代表v的第一位的值位1

