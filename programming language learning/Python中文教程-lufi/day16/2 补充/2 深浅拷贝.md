深浅拷贝一般都是说可变类型:set list dict(因为不可变类型进行深浅拷贝的时候都是无意义的-内部都不会进行拷贝)

- 浅拷贝
- 不可变类型,不拷贝
```python
import copy  
  
v1 = "wupeiqi"  
print(id(v1)) # 2561034519600  
  
  
v2 = copy.copy(v1)  
print(id(v2)) # 2561034519600
```

按理来说拷贝v1之后,v2的内存地址应该不同,但是由于python内部优化机制,内存地址是相同的,因为对不可变类型而言,如果以后修改值,会重新创建一份数据,不会影响原数据,所以不拷贝也可以

不可变类型浅拷贝是不会拷贝数据,而是将两个变量名指向同一个地址

- 可变类型,只拷贝第一层
```python
v1 = ["11",22,(12,2,3,),{"1":123}]  
v2 = copy.copy(v1)  
print(f'{id(v1)}\n', f'\r{id(v2)}\n')  
"""  
这样输出的结果才能是对的，在第二行前面没有空格  
2547528796160  
2547528976512  
"""  
  
print(id(v1[0])) # 2265232147824  
print(id(v2[0])) # 2265232147824  
"""  
这两个是同一地址，所以要明白拷贝的是列表，而不是列表内的元素  
"""
```
![[Pasted image 20231028133114.png]]
列表中的元素一定是指向同一个内存地址的
做浅拷贝的时候只会拷贝第一层的内容,也就是指向第一层的内存地址
对于第一层中的可变类型,不会进行拷贝,也是指向同一内存地址
```python
print(id(v1[3])) # 2311188512320  
print(id(v2[3])) # 2311188512320
```

```扩展垃圾回收机制
问: 在pycharm中编写py文件，我首先v1 = “wupeiqi”，然后打印id(v1)，然后给v1 = [11,22,33]，这个时候打印id(v1)，v1因为被后边的变量覆盖了，所以内存地址也会改变是吗

答: 在Python中，变量的内存地址是由其值的类型和内容决定的。当你创建一个变量时，它的内存地址会根据它的值分配。如果你在代码中将变量 `v1` 设置为不同类型或内容的值，它的内存地址可能会改变。

在你的描述中，首先 `v1 = "wupeiqi"`，然后打印 `id(v1)`，接着将 `v1` 赋值为列表 `[11, 22, 33]`。在这个过程中，`v1` 的值从字符串变为列表，因此它的内存地址可能会发生变化。

不过，请注意，Python的内存管理机制是复杂的，内存地址的改变不仅仅由变量的值决定，还受到诸如垃圾回收等因素的影响。在某些情况下，相同的值可能会分配到相同的内存地址，以优化性能。因此，尽管在某些情况下变量的内存地址可能会改变，但这不是一定发生的情况。

如果你需要确保变量的内存地址不变，可以使用 `id()` 函数来检查。但需要谨记，这种行为可能因Python解释器和版本而异，不要将其作为编程逻辑的重要依赖。

问: 在这个操作后边，我再将v1赋予值“wupeiqi”也就是v1=“wupeiqi"，这个时候打印id，发现，这里的v1=wupeiqi跟前边的v1=wupeiqi的id是一样的，这是因为你说的垃圾回收的因素吗

答: 正确，这是因为Python的垃圾回收机制和对象缓存。Python中的一些常见字符串（例如小字符串，包括字母和数字）会被缓存，以便节省内存和提高性能。这意味着相同的字符串值在内存中只分配一次，而后续的变量赋值将引用相同的内存地址。

所以，当你将 `v1` 设置为字符串 `"wupeiqi"` 时，Python可能会重用之前已经缓存的字符串，因此它的内存地址与之前的相同。

这种行为是Python的一种优化机制，它有助于减少内存消耗，特别是对于常见的不可变数据类型（如字符串和整数）。不过，请注意，不是所有的字符串都会被缓存，这种行为可能受到Python版本和解释器的影响。所以在编写代码时，最好不要依赖于特定字符串的内存地址是否相同，而是应该使用比较运算符来比较它们的值。
```


- 深拷贝
- 不可变类型,不拷贝
```python
# 深拷贝  
v1 = "wupeiqi"  
print(id(v1)) # 2838833628144 发现这里命名跟之前一样的时候存到的内存地址还是一样的  
  
v2 = copy.deepcopy(v1)  
print(id(v2)) # 2838833628144 内存地址还是一样的，所以没什么意义
```

- 可变类型,无论什么级别哪一层都会拷贝，不可变类型数据永远不会拷贝 
```python
# 深拷贝，可变类型，无论什么级别哪一层都会拷贝，不可变类型数据永远不会拷贝  
v1 = ["11",22,(12,2,3,),{"1":123},[11,22]]  
v2 = copy.deepcopy(v1)  
print(id(v1)) # 2485736786560  
print(id(v2)) # 2485736779200  
  
print(id(v1[0])) # 2485736408112  
print(id(v2[0])) # 2485736408112  
  
print(id(v1[3])) # 2485733162560  
print(id(v2[3])) # 2485733540224
```

- 特殊的 元组是不可变类型
	- 浅拷贝,永远不会拷贝
	- 深拷贝,当元组的元素中都是不可变类型的时候,永远不会拷贝
	- 深拷贝,当元组中的元素存在可变类型,可变类型会被拷贝
```python
v1 = (11,22,[11,22],{11,22},{11:22})
v2 = copy.deepcopy(v1)
  
print(id(v1)) # 1611374442032  
print(id(v2)) # 1611371098736
```
![[Pasted image 20231028135513.png]]