## 1. 环状的双向链表 refchain

假设下面三个元素组成了一个环，如果这三个元素可以通过元素找到上一个和下一个，并且是双向的

![[Pasted image 20231205215121.png]]

python中创建的所有对象都会创建到一个双向链表中
```python
name = "wupeiqi"
age = 18
hobby = ["basketball", "beautiful"]
```
![[Pasted image 20231205215257.png]]
不同的对象储存到这个双向链表中，不同点：
- 储存的数据对象不一样
相同点：
```python
name = "alex"
```
内部会创建一些数据【上一个的指针/上一个对象，并储存下一个对象，类型】
`对于这里的alex，就是会储存你上一个对象refchain，下一个对象老男孩`
并且这里还会储存：
- 类型
- 引用个数
此时如果创建一个new
```python
new = name
```
这个时候会在创建这个new也指向alex，这时候alex的计数器就变为2

这时候我们可以认为，创建每一个对象，不管数据类型是什么，都会创建4个值：
- 上一个对象/指针
- 下一个对象
- 类型
- 引用个数

不同点是：
- 比如说int，就会储存一个val=？
- 如果是list，就会储存items=元素，元素个数

这些都会

```c
static PyObject refchain = {&refchain, &refchain};
```

### 简单看一下源码

```c
# define PyObject_HEAD    PyObject ob_base;
# define PyObject_VAR_HEAD PyVarObject ob_base;

// 宏定义，包含 上一个，下一个，用于构造双向链表用（放到refchain链表中的时候要使用到）
# define _PyObject_HEAD_EXTRA   \
	struct _object * _ob_next;   \
	struct _object * _ob_prev;

typedef struct _object {
	_PyObject_HEAD_EXTRA // 用于构造双向链表
	Py_ssize_t ob_refcnt; // 引用计数器
	struct _typeobject * ob_type; // 数据类型
} PyObject;

typedef struct {
	PyObject ob_base; // PyObject对象
	Py_ssize_t ob_size; /* Number of items in variable part, 即：元素个数 */
} PyVarObject;
```

只是一个结构体，结构体中定义了几个值
宏定义中的两个值
结构体内部存 ob_next 和 ob_prev

上面一个结构体储存的是上一个和下一个对象，引用计数器和数据类型
下面一个结构体储存的是不同的值

所以python实现的时候，使用的是一个PyObject结构体用来封装4个相同的值，然后另一个结构体PyVarObject，其中引用了一个PyObject ob_base，然后加了一个ob_size代表元素个数，这样可以用来体现多个元素储存的对象，会在PyObject结构体之外加ob_size的部分

接下来我们可以看每个数据类型内部都封装了哪些值

### 2. 类型封装结构体
#### float类型

```python
a1 = 1.191299
```
这个时候python里面创建了一个float元素
这就会在结构体中创建对应的值
```c
typedef struct {
	PyObject_HEAD
	double ob_fval;
} PyFloatObject;
```
这里结构体引用了PyObject_HEAD
这里代表
```c
# define PyObject_HEAD    PyObject ob_base;
```
看这里就是代表的PyObject ob_base
```c
# define PyObject_HEAD    PyObject ob_base;
# define PyObject_VAR_HEAD PyVarObject ob_base;

// 宏定义，包含 上一个，下一个，用于构造双向链表用（放到refchain链表中的时候要使用到）
# define _PyObject_HEAD_EXTRA   \
	struct _object * _ob_next;   \
	struct _object * _ob_prev;

typedef struct _object {
	_PyObject_HEAD_EXTRA // 用于构造双向链表
	Py_ssize_t ob_refcnt; // 引用计数器
	struct _typeobject * ob_type; // 数据类型
} PyObject;

typedef struct {
	PyObject ob_base; // PyObject对象
	Py_ssize_t ob_size; /* Number of items in variable part, 即：元素个数 */
} PyVarObject;
```
我们这里可以注意到一个PyObject的基础内容是包含有
```c
# define _PyObject_HEAD_EXTRA   \
	struct _object * _ob_next;   \
	struct _object * _ob_prev;
```
这里面代表的前一个后一个的指针
还有
```c
typedef struct _object {
	_PyObject_HEAD_EXTRA // 用于构造双向链表
	Py_ssize_t ob_refcnt; // 引用计数器
	struct _typeobject * ob_type; // 数据类型
} PyObject;
```
这里创建的引用计数器和数据类型
所以回到float的构造体中看
```c
typedef struct {
	PyObject_HEAD
	double ob_fval;
} PyFloatObject;
```
这里额外添加了一个ob_fval用来存储赋值的float值，上边的代指公用的PyObject_HEAD
内部会创建：
```
_ob_next = refchain中的下一个对象
_ob_prev = refchain的上一个对象
ob_refcnt = 1
ob_type = float
ob_fval = 1.191299
```
这里面的refcnt默认是1
这里prev和next怎么存呢？
这里的ob_next和ob_prev是用于指向refchain的上一个和下一个对象


#### int类型
```c
struct _longobject {
	PyObject_VAR_HEAD
	digit ob_digit[1];
};
/* Long (arbitrary precision) integer object interface */
typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */
```
这里创建的也是一样的，创建结构体，结构体有几个值，创建的对象中就有几个值

#### list类型
```c
typedef struct{
	PyObject_VAR_HEAD
	PyObject **ob_item;
	Py_ssize_t allocated;
}PyListObject;
```

#### tuple类型
```c
typedef struct {
	PyObject_VAR_HEAD
	PyObject *ob_item[1];
}PyTupleObject;
```

#### dict类型
```c
typedef struct {
	PyObject_HEAD
	Py_ssize_t ma_used;
	PyDictKeysObject *ma_keys;
	PyObject **ma_values;
}PyDictObject;
```


## 3 引用计数器

```python
v1 = 3.14
v2 = 999
v3 = (1,2,3)
```

当有这些对象的时候，在内部会根据数据类型的不同找到其对应的结构体，根据结构体中的字段来进行创建相关数据
然后将对象添加到refchain双向链表中
在源码中，有两个关键的结构体，PyObject和PyVarObject的两个结构体
前一个是存储的公共的上一个，下一个，双向链表，数据类型，引用个数
PyVarObject是当有多个元素组成的数据类型的时候，就是会使用这个来创建多个元素的size，跟PyObject的区别就是加了一个ob_size

**python3中的int默认是long，所以是多个元素组成的字符串的机制，所以也是基于PyOjbect结构体实现的**

每一个对象创建完，放到refchain中的时候，每一个对象都有一个ob_refcnt
最开始创建默认是1，当有其他变量引用这个对象的时候，引用计数器就会发生变化

比如：
- 引用
```python
a = 123
b = a
```
这时候因为是int创建一个结构体，里面有ob_refcnt=1，然后将b=a的时候这里的就+1

- 删除引用
```python
a = 999
b = a
del b # b变量删除，b对应的对象，引用计数器-1
del a # a变量删除，对应的引用计数器-1

```
当一个对象的引用计数器为0的时候，就没有人使用这个对象了，这代表这个对象就是垃圾了，就会进行垃圾回收
垃圾回收：
1. 将对象从refchain链表中移除
2. 将对象进行销毁，代表将内存归还给系统


我们可以看图，了解一下这个双向链表的样子
![[Pasted image 20231206002738.png]]
这里引用了很多的sb，所以在这里alex这个值代表的对象的引用计数器会变为5
当创建一个新的对象的时候，会在refchain中添加一个对应的值，然后引用计数器为1
当计数器变为0的时候就会移除掉这个变量
