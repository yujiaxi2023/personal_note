
## 小结

在python中维护了一个refchain的双向环状链表，这个链表中存储创建的所有对象，每种类型的对象中都有1个叫ob_refcnt的值，就是引用计数器的值，引用计数器变为0的时候进行垃圾回收（对象销毁，refchain中移除）

但是python中还会对于一些可以有多个元素组成的对象，可能存在有循环引用的问题，为了解决这个问题，python又引入了标记清除和分代回收。在其内部维护了4个链表：
- refchain 维护所有对象
- 2代 10次
- 1代 10次
- 0代 700个
在源码的内部，当达到各自的阈值的时候，就会触发扫描链表进行标记清除的动作。（如果有循环引用就各自在引用计数器的位置-1）

**在python内部还可以进行优化的一个点**
## python缓存

### 1. 池 （int类型，字符串）

为了避免重复的创建和销毁一些常见对象，维护一个池。
```python
v1 = 7
v2 = 9
v3 = 9
```
按理来说，在python内部会创建3个对象，加入到refchain中
但是为了节省资源，其实不会创建3个对象
因为python会经常使用一些数字
所以启动解释器的时候，python内部会帮助我们创建：-5，-4，··· 257
所以内部就不会开辟内存，创建这些常见的数字，而是直接去池中加载最开始创建的这些数值。
所以这个时候我们
```python
print(id(v2), id(v3))
```
会发现内存地址是一样的
所以只要不是超过了python这个池的数字，就不会创建新的内存地址进行运行。
这里创建的小数据池中的引用计数器不会变为0，因为引用计数器最开始初始化为1，应用一次就+1，删除永远不会删除为0

### free_list机制（float/list/tuple/dict）

当引用计数器为0的时候，按理来说应该进行回收，但是在python内部并不会进行回收，而是将对象添加到一个free_list链表中当缓存。以后再去创建对象的时候，不再重新开辟内存，而是直接使用free_list

```python
v1 = 3.14 # 开辟内存，内部储存结构体中定义那几个值，并存到refchain中

del v1 # 这时候从refchain中移除，按理来说应该销毁，但是这时候会将对象添加到free_list中

v9 = 99.99 # 不会重新开辟内存，会从free_list中获取对象，对象内部的数据进行初始化，再放到refchain中
```
这时候会创建一个对象，引用计数器设定为1
此时进行del操作，按理说开辟的内存。但是这时候只是从refchain中移除，而不是销毁数据，而是移动到free_list中
当缓冲池满了就进行销毁
需要注意的是free_list是维护指向内存的指针而不是数据的值，free_list中的每个元素都是指向分配内存块的一个指针

所以有的时候引用计数器为0的时候，有的时候是销毁，有的时候是缓存
但是free_list具体是能够维护多少个对象，这是由数据类型来确定的

- float类型
```python
v1 = 3.14
print(id(v1)) # 这时候给出一个内存地址A
del v1 # 引用计数器-1，变为0的时候，从refchain中移动到float的free_list中
v2 = 9999.1 # 首先从free_list中获取对象，并重置为9999.1，如果free_list为空就重新开辟内存
print(if(v2)) # 这时候的内存地址还是A

# 注意，引用计数器为0的时候，会先判断free_list中缓存个数是否满了，未满就将对象缓存，已经满了就将对象销毁
```

- int类型，不是基于free_list，而是维护一个small_list链表保存常见的数据（小数据池），范围是`-5 <= value < 257`，即：重复使用这个范围的正数的时候，不会重新开辟内存
```python
v1 = 38 # 去小数据池small_ints中获得38整数对象，将对象添加到refchain中并让引用计数器+1
print(id(v1)) # 这时候会打印一个内存地址B
v2 = 38 # 去小数据吃small_ints中获取38证书对象，将refchain中的对象的引用计数器+1
print(id(v2)) # 这时候内存地址是B

# 注意：再解释器启动的时候-5~256就已经被加入到small_ints链表中且引用计数器初始化为1，代码中使用的值，直接去small_ints中拿来用并将引用计数器+1就可以。另外，small_ints中的数据引用计数器永远不会为0（初始化的时候就设置为1），所以不会被销毁
```

- list类型，维护的free_list数组，最多可以缓存80个list对象
```python
v1 = [11,22,33]
print(id(v1)) # 输出是内存地址C
del v1 
v2 = ["we", 'peiqi'] 
print(id(v2)) # 输出的内存地址是C
```

- tuple类型，维护的free_list数据且数组容量20，数组中元素可以是链表且每个链表最多可以容纳2000个元组对象，元组的free_list数组再储存数据的时候，是按照元组可以容纳的个数为所以找到free_list数组中对应的链表，并添加到链表中
```python
v1 = (1,2)
print(id(v1)) 
del v1 # 因为元组的数量为2，所以会把这个对象缓存到free_list[2]的链表中
v2 = ("wupeiqi", "alex") # 不会重新开辟内存，而是去free_list[2]对应的链表中拿到一个对象来使用
print(id(v2)) 
```
元组是比较特殊的，元组维护的free_list是
```python
free_list = [0,1,2,3,4,5,6,7...,19] # 最多到20个
			[空元组] [有1个元素的元组]···[有19个元素的元组] # 这里面会放链表，链表里面会放不同的元组
						2000个
```
所以元组的链表中是将这个v1删除后将其放入到有2个元素的元组所属的链表中，里面会最大储存2000个2个元素的元组对象，所以一旦创建了超过2000个2个元素的元组，就超出了缓存机制的上限。但是如果是之前只缓存了2个元素的元组对象，如果创建3个元素的元组对象的时候会重新分配内存进行创建。


- dict类型，维护的free_list数组最多可以缓存80个对象
```python
v1 = {"k1": 123}
print(id(v1)) # 输出内存地址D
del v1
v2 = {"name": "wupeiqi", "age": 18, "gender": "man"}
print(id(v2)) # 输出的内存地址D
```

- str类型，维护`unicode_latin1[1]`链表，内部将所有的ascii字符缓存起来，以后使用就不会反复创建
```python
v1 = "A"
print(id(v1)) # 输出一个内存地址E
del v1
v2 = "A"
print(id(v2)) # 输出是同样的内存E

# 除此之外，python内部还有驻留机制，针对的只有字母，数字，下划线的字符串（见源码Objects/codeobject.c)，如果内存中已经存在就不会重新创建而是使用原来的地址（不会像free_list一直在内存中存货，只有内存中有才能重复使用）
v1 = "wupeiqi"
v2 = "wupeiqi"
# 此时两者的id是一样的
```
