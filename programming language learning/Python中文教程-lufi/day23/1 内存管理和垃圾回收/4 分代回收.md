在python的内部某一个时刻，某种情况下触发，会扫描下面的链表（可能出现循环引用的链表），扫描所有的元素，然后找到每个元素中的每个元素，如果发现了有循环引用的问题，就是比如在这里找11，然后找到了另一个元素，比如说列表中也含有11，然后根据这个11找地址又找回到本身的内存，这样就发现了循环引用。

标记清除中可能会出现问题：
- 什么时候进行扫描（刚才的某种情况下是什么？）
- 可能存在循环引用的链表，扫描代价非常大，每次耗时都会很久（因为每次扫描不仅是要扫描对象对应的值，还要扫描内部的所有元素，这样下来，基数就会非常大了）

## 分代回收

分层了3个链表
![[Pasted image 20231206153910.png]]
将可能存在循环引用的对象维护成3个链表：
- 0代：0代中如果对象的个数达到700个扫描1次
- 1代：1代中如果0代扫描了10次，则1代扫描1次
- 2代：1代扫描10次，则2代扫描1次

在python中创建列表数据这种可变数据类型的时候，会首先将元素放到0代中，一直到0代达到700个的时候，会进行1次扫描，然后找到循环引用的对象，并执行-1操作，如果是垃圾，就进行垃圾回收，如果不是垃圾，就将0代中的这个对象升级到1代中，并且记录0代扫描了1次
这个时候0代中没有数据了（因为都转移到1代中），这时候创建新的数据，等到再次达到700的时候，进行扫描，重复上边的操作
直到1代中记录的扫描次数达到了10次之后，对1代进行扫描，进行类似的操作。

注意：
这里0代进行计数的是元素的个数
`比如创建一个列表[11,22,33]，这时候0代中储存的是4个引用，列表的引用，11，22，33这三个元素的引用`
1代和2代记录的是次数
