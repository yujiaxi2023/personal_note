一般的编程语言使用引用计数器进行垃圾回收就已经很简单明了了，但是如果只是使用引用计数器进行垃圾回收会存在一个bug

## 循环引用问题

```python 
v1 = [11,22,33] # refchain中创建一个列表对象，由于v1=对象，所以列表的引用对象计数器为1
v2 = [44,55,66] # refchain中在创建一个列表对象，因为v2=对象，所以列表的引用对象计数器为1
v1.append(v2) # 把v2追加到v1中，则v2对应的[44,55,66]对象的引用计数器加1，最终是2
v2.appned(v1) # 把v1追加到v2中，则v1对应的[11,22,33]对象的引用计数器加1，最终是2

del v1 # 引用计数器-1
del v2 # 引用计数器-1
```
![[Pasted image 20231206151926.png]]
这个时候引用计数器因为两个都变1了，但是因为v1和v2就都删除了，但是因为我们引用计数器没有归零，所以并不会被当作是垃圾，所以本来应该回收的垃圾（因为没有对象指向这块内存了），就会持续存在在双向链表中

这种代码使用的更多，程序会一直运行，会一直消耗掉所有的内存，这种很傻逼

所以在python底层不会只有引用计数器
所以引入了另一个机制，叫做标记清除

## 标记清除

目的：为了解决引用计数器的循环引用的问题

如何实现？
在python的底层，再去维护一个链表，这个链表中放的是可能存在循环引用的对象（只有是可以改变的元素才会出现这种循环引用的错误）（list/tuple/dict/set）

这里面会再维护一个链表
![[Pasted image 20231206152513.png]]
![[Pasted image 20231206152522.png]]
上面一个是正常的链表，下面一个是只用于储存那种可变化的数据类型的对象
在python的内部某一个时刻，某种情况下触发，会扫描下面的链表（可能出现循环引用的链表），扫描所有的元素，然后找到每个元素中的每个元素，如果发现了有循环引用的问题，就是比如在这里找11，然后找到了另一个元素，比如说列表中也含有11，然后根据这个11找地址又找回到本身的内存，这样就发现了循环引用。
如果发现了这样的情况，就让双方的引用计数器-1，如果是0就进行垃圾回收。