## 总结

1. 函数参数传递的是内存地址
- 想重新创建一份数据在传递给参数，可以手动拷贝一份
当不想使用内存地址的时候，可以使用下面命令进行拷贝
```python
import copy

copy.deepcopy()
```
python默认是传递内存地址，在很多其他的语言中，默认使用的是拷贝一份数据传递到函数中

- 特殊：参数是动态参数的时候通过`* **`进行传参，会将数据循环添加到参数中（类似于拷贝一份）

```python
def func(*args, **kwargs):  
    print(args, kwargs)  
  
  
func(*[11, 22, 33], **{"k1": 1, "k2": 2})
```

在这里传递的不是内存地址，是将每个元素获得之后拷贝一份添加到args和kwargs


2. 函数的返回值也是内存地址（函数执行完毕后，其内部的所有变量都会被销毁，引用计数器为0时候，数据也销毁）
```python
def func():  
    name = [11, 22, 33]  # 引用计数器1
    data = name # 引用计数器2
	# 函数执行完毕后进行垃圾回收
  
func()  
  
  
def func():  
    name = [11, 22, 33]  # 引用计数器1
    return name  # 返回数据到data，引用计数器2
  
  
data = func()  # 执行完了引用计数器1
while True:  
    print(data)
```

3. 当函数的参数有默认值和默认值是可变类型和函数内部会修改内部元素（有坑）
```python
# 内部会维护一个列表 [] 只要b不传值则始终使用都是这个列表
def func(a,b=[])
	b.append(a)
```

4. 定义函数写形式参数的时候可以使用`*和**`，执行函数的时候可以使用
5. 函数名其实也是个变量，它可以做列表，字典，集合等元素（可哈希）
6. 函数名可以被重新赋值，也可以做另外一个函数的参数和返回值
7. 掌握print和return区别，分析代码的执行流程
8. 函数是以参数为作用域
9. 在局部作用域中寻找某数据时候，优先使用自己的，自己没有就在上级作用域中寻找
10. 基于global关键字可以在局部作用域中实现对全局作用域中的变量（全局变量）重新赋值

## 作业

```python
# 1. 如何查看值的内存地址  
"""  
value = "abc"  
print(id(value))  
"""  
  
# 2. 函数的参数传递的是引用（内存地址）还是值（拷贝一份）  
"""  
参数默认使用的内存地址  
"""  
  
# 3. 看代码写结果  
"""  
v1 = {}  
v2 = v1  
v1["k1"] = 123  
  
print(v1, v2)  
"""  
  
# 4. 看代码写结果  
"""  
def func(k, v, info={}):  
    info[k] = v    return info  
  
v1 = func(1, 2)  
print(v1)  # {1: 2}  
  
v2 = func(4, 5, {})  
print(v2)  # {4:5}  
  
v3 = func(5, 6)  
print(v3)  # {1:2, 5:6}  
"""  
  
# 5. 看代码写结果  
"""  
def func(k, v, info={}):  
    info[k] = v    return info  
  
v1 = func(1, 2)  
v2 = func(4, 5, {})  
v3 = func(5, 6)  
  
print(v1, v2, v3)  # {1:2, 5:6}   {4:5}   {1:2, 5:6}  
"""  
  
# 6. 简述5和4的不同  
"""  
4中的v1和v3的变量指向的都是函数内部维护的那个列表的内存地址  
    先print(v1)时候，函数内部维护的列表的值当时是{1,2}  
    最后print(v3)时候，函数内部维护的列表的值已经被修改为{1:2,5:6}  
    5中的v1和v3的变量也是指向维护的列表的值  
    但是是最后print的结果，所以这个时候返回的内存的值就是{1:2, 5:6}  
"""  
  
# 7. 看代码写结果  
"""  
def func(*args, **kwargs):  
    print(args, kwargs)    return args, kwargs  
  
v1 = func(11, 22, 33)  # (11,22,33) {}  
print(v1)  
  
v2 = func([11, 22, 33])  # ([11,22,33],) {}  
print(v2)  
  
v3 = func(*[11, 22, 33])  # (11,22,33) {}  
print(v3)  
  
v4 = func(k1=123, k2=456)  # () {"k1":123, "k2":456}  
print(v4)  
  
v5 = func({"k1": 123, "k2": 456})  # ({"k1":123, "k2":456}) {}  
print(v5)  
  
v6 = func(**{"k1": 123, "k2": 456})  # () {"k1":123, "k2":456}  
print(v6)  
  
v7 = func([11, 22, 33], **{"k1": 123, "k2": 456})  # ([11,22,33]) {"k1":123,"k2":456}  
print(v7)  
  
v8 = func(*[11, 22, 33], **{"k1": 123, "k2": 456})  # (11,22,33) {"k1":123, "k2":456}  
print(v8)  
"""  
  
# 8. 看代码写结果  
"""  
def func(*args, **kwargs):  
    prev = "-".join(args)    data_list = []    for k, v in kwargs.items():        item = f"{k}-{v}"        data_list.append(item)        content = "*".join(data_list)    return prev, content  
  
v1 = func("beijing", "shanghai", city="shenzhen", count=99)  
print(v1)  # ("beijing-shanghai","city-shenzhen*count-99)  
  
v2 = func(*["beijing", "shanghai"], **{"city": "shenzhen", "count": 99})  
print(v2)  # ("beijing-shanghai","city-shenzhen*count-99)  
"""  
"""  
结果是一样的但是传参形式不一样  
上边一个是使用的传统的位置参数和关键字参数传参传到元组和字典中  
下面是将动态参数进行传参，将列表字典打散传入元组和字典中  
"""  
  
# 9. 补充代码，实现获得天气信息并按照指定格式写入文件中【重点】  
"""  
# 获取天气信息实例  
import requests  
  
def write_file(**kwargs):  
    data_list = []  
    row_dict = kwargs["weatherinfo"]    for k, v in row_dict.items():        group = f"{k}-{v}"        data_list.append(group)    row_string = ",".join(data_list)  
    with open("xxxx.txt", mode="a", encoding="utf-8") as file_object:        file_object.write(f"{row_string}\n")  
  
def get_weather(code):  
    url = f"http://www.weather.com.cn/data/ks/{code}.html"    res = requests.get(url=url)    res.encoding = "utf-8"    weather_dict = res.json()    return weather_dict  
city_list = [  
    {"code":"101020100", "title":"上海"},  
    {"code":"101010100", "title":"北京"},  
]  
  
for item in city_list:  
    result_dict = get_weather(item["code"])    write_file(**result_dict)"""  
  
# 10.看代码写结果  
"""  
def func():  
    return 1,2,3  
val = func() # 得到的元组类型  
# 判断是否是元组类型  
print(type(val) == tuple) # True  
print(type(val) == list) # False  
print(type(val) == dict) # False  
"""  
"""  
info = {  
    "1":[11,22,33],    "2":{"k1":123, "k2":456, "k3""999"}}  
  
index = input("plz input num:")  
value = info[index]  
if type(value) == list:  
    print(value[0],value[1],value[2])elif type(value) == dict:  
    print(value["k1"],value["k2"],value["k3"])"""  
  
# 11.看代码写结果  
"""  
def func(users,name):  
    users.append(name)    print(users)  
result = func(["wupeiqi", "lijie"], "alex") # ["wupeiqi","lijie","alex]  
print(result) # None  
"""  
  
  
# 12.看代码写结果  
"""  
def func(v1):  
    return v1 * 2  
  
def bar(arg):  
    return "%s 是什么？" % (arg,)  
  
  
val = func("你")  # “你你“  
data = bar(val)  
print(data)  # 你你 是什么玩意？  
"""  
  
# 13. 看代码写结果  
"""  
def func(v1):  
    return v1 * 2  
  
def bar(arg):  
    msg = "%s 是什么？" % (arg,)  
    print(msg)  # return变为print之后 返回值默认为None  
  
  
val = func("你")  
data = bar(val)  # 你你 是什么？  
print(data)  # None  
"""  
  
# 14. 看代码写结果  
"""  
def func():  
    data = 2 * 2    return data  
  
data_list = [func, func, func]  
  
for item in data_list:  
    v = item()  # v是执行函数func，结果是4  
    print(v)  
  
# 结果是4 4 4  
"""  
# 15. 分析代码，写结果  
"""  
def func(handler, **kwargs):  
    extra = {        "code": 123,        "name": "wupeiqi"    }    kwargs.update(extra)    return handler(**kwargs)  # 看作一个handler函数传入一个动态参数  
  
  
def something(**kwargs):  
    return len(kwargs)  
  
def killer(**kwargs):  
    key_list = []    for key in kwargs.keys():        key_list.append(key)        return key_list  
  
v1 = func(something, k1=123, k2=456)  # {k1:123,k2:456}  
# {k1:123,k2:456,"code":123,"name":"wupeiqi"}  
# 4个键值对，容器中的元素是4个，结果就是4  
print(v1) # 4  
  
v2 = func(killer, **{"name": "wupeiqi", "age": 18}) # {"name": "wupeiqi", "age": 18}  
# {"name": "wupeiqi", "age": 18, "code": 123} 翻入函数killer执行  
# keys方法会找出所有的key  
# ["name", "age", "code"]依次添加到列表中  
print(v2)  
"""  
  
# 16. 两个结果输出的分别是什么？请简述原因  
"""  
def func():  
    return 123  
v1 = [func, func, func, func]  
print(v1) # 列表，内部元素都是函数（函数名在列表的索引位置，函数名代指函数）  
  
v2 = [func(), func(), func(), func()]  
print(v2) # 列表，内部元素都是返回值指向的内存地址，结果是123  
"""  
  
# 17. 看代码知结果  
"""  
v1 = "wupeiqi"  
  
def func():  
    print(v1)  
func() # "wupeiqi" 局部作用域找不到找全局的，有就输出  
func() # "wupeiqi"  
"""  
  
# 18. 看代码知道结果  
"""  
v1 = "wupeiqi"  
  
def func():  
    print(v1)  
func() # "wupeiqi"  
  
v1 = "laonanren"  
  
func() # "laonanren"  
"""  
  
# 19. 看代码知道结果  
"""  
NUM_LIST = []  
SIZE = 18  
  
def f1():  
    NUM_LIST.append(8) # 可变类型进行修改  
    SIZE = 19  
def f2():  
    print(NUM_LIST)    print(SIZE)  
f2() # [] 18 第一次执行是找到的全局变量是空列表  
f1() # 无输出 无返回值无打印  
f2() # [8] 18  
"""  
  
# 20. 看代码知道结果  
"""  
NUM_LIST = [11,22,33]  
SIZE = 18  
  
def f1():  
    global NUM_LIST    global SIZE    NUM_LIST = "wupeiqi"    SIZE = 19  
def f2():  
    print(NUM_LIST)    print(SIZE)  
f2() # [11,22,33] 18  
f1() # 无输出  
f2() # wupeiqi 19  
"""  
  
# 21. 资源下载器 v1版本  
"""  
import requests  
from fake_useragent import FakeUserAgent  
  
SELECTED_IMAGE_SET = set() # 已经下载的图片ID（序号）  
SELECTED_VIDEO_SET = set()  
SELECTED_NBA_SET = set()  
  
def download(file_path,url):  
  
    res = requests.get(        url=url,        headers={            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36 Edg/118.0.2088.46"        }    )  
    with open(file_path, mode="wb") as f:        f.write(res.content)  
def download_image():  
    total_image_dict = {        "1": ("吉他男神", "https://gd-hbimg.huaban.com/748e00a360fa2ecfeadc73e4bbc8a79998f73464695fd-GnVzNW_fw1200"),  
        "2": ("漫画美女", "https://gd-hbimg.huaban.com/25da2ec0909263b568b356dc1eceba2014675fd98c3d8-JxHEKu_fw658webp"),  
        "3": ("游戏地图", "https://gd-hbimg.huaban.com/511ca0b8b6d5f192e146cadb007de0cc9bea6cfe1d72ea-GYf2iX_fw658webp"),  
        "4": ("alex媳妇", "https://gd-hbimg.huaban.com/01140eb1ef1ebae90aaa631ae7816a27633d50ae8733b-72HBCD_fw658webp")  
    }    while True:        # 输出 1.吉他男神；2.漫画美女；3.游戏地图；4.alex媳妇  
        text_list = []        for num, item in total_image_dict.items(): # 将键值对迭代提取，形成一个视图对象  
            if num in SELECTED_IMAGE_SET:                continue            data = f"{num}.{item[0]}"            text_list.append(data)        if text_list:            text = ";".join(text_list)        else:            text = "无可下载选项"  
        # 输出 1.吉他男神；2.漫画美女；3.游戏地图；4.alex媳妇  
        # 希望下载了其中的内容后，就不再显示  
        print(text)  
  
        index = input("请输入要选择的序号(Q/q退出):")  
        if index.lower() == "q": # 返回上一步  
            return # return终止了回到while循环，让用户选择专区  
  
        if index in SELECTED_IMAGE_SET: # 选择序号 判断输入的序号  
            print("已经下载，无法继续下载，请重新选择")  
            continue  
        group = total_image_dict.get(index)        if not group:            print("序号不存在，无法进行下载，请重新选择！")  
            continue  
        # 下载图片  
        file_path = f"{group[0]}.png"        download(file_path, group[1])  
        # 已经下载的集合中  
        SELECTED_IMAGE_SET.add(index)  
  
  
def download_video():  
    pass  
def download_nba():  
    pass  
print("欢迎使用xxx系统")  
func_dict = {  
    "1": download_image,    "2": download_video,    "3": download_nba}  
  
while True:  
    print("1.花瓣网图片；2.抖音短视频；3.NBA集锦")  
    choice = input("请选择序号(Q/q)：")  
    if choice.upper() == "Q":        break    func = func_dict.get(choice)    if not func:        print("输入错误，重新选择")  
        continue    # 进入专区  
    func()"""  
# 21. 资源下载器 v2版本  
import requests  
  
DB = {  
    "1": {  
        "area":"花瓣网专区图片",  
        "total_dict": {  
            "1": ("吉他男神", "")  
        },  
        "ext":"png",  
        "selected":set()  
    },  
    "2":{  
        "area":"抖音短视频",  
        "total_dict":{  
            "1": {"title":"","url":""},  
        },  
        "ext":"mp4",  
        "selected":set()  
    },  
    "3":{  
        "area":"NBA视频",  
        "total_dict":{  
            "1":(""),  
        },  
        "ext":"mp4",  
        "selected":set()  
    }  
}  
  
def download(file_path,url):  
  
    res = requests.get(  
        url=url,  
        headers={  
            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36 Edg/118.0.2088.46"  
        }  
    )  
  
    with open(file_path, mode="wb") as f:  
        f.write(res.content)  
  
  
def handler(area_info):  
    # 进入专区提醒  
    summary = f"欢迎进入{area_info['area']}" # 不能都用双引号  
    print(summary)  
  
    # 专区中选择下载  
    while True:  
        text_list = []  
        for num, item in area_info['total_dict'].items():  
            if num in area_info['selected']:  
                continue  
            if type(item) == tuple:  
                data = f"{num}.{item[0]}"  
            else:  
                data = f"{num}.{item['title']}"  
            text_list.append(data)  
        if text_list:  
            text = ";".join(text_list)  
        else:  
            text = "无可下载选择"  
  
        print(text)  
        index = input("请输入要选择的序号(Q/q)：")  
        if index.upper() == "Q":  
            return  
  
        if index in area_info['selected']:  
            print("已下载，无法继续下载，请重新选择！")  
            continue  
  
        group = area_info['total_dict'].get(index)  
        if not group:  
            print("序号不存在，重新选择")  
            continue  
  
        if type(group) == tuple:  
            title, url = group  
        else:  
            title, url = group['title'], group['url']  
  
        file_path = f"{title}.{area_info['ext']}"  
        download(file_path,url)  
  
        area_info['selected'].add(index)  
  
  
  
  
print("欢迎使用xxx系统")  
while True:  
    print("1.花瓣网图片；2.抖音短视频；3.NBA集锦")  
    choice = input("请选择序号(Q/q)：")  
    if choice.upper() == "Q":  
        break  
  
    # 选择序号：  
    area_dict = DB.get(choice)  
  
    if not area_dict:  
        print("输入错误，重新选择")  
        continue  
    # 进入专区  
    handler(area_dict)
```
