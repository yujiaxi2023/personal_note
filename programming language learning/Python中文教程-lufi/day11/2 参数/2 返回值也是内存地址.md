### 1.2 函数的返回值是内存地址

```python
def func():  
    data = [11, 22, 33]  
    return data  
  
v1 = func()  
print(v1) # [11,22,33]
```

上述代码执行的过程：
- 执行func函数
- `data = [11,22,33]`创建一块内存区域，内部储存`[11,22,33`，data变量指向这块内存地址
- `return data` 返回data指向的内存地址
- v1 接收返回值，所以v1和data都指向`[11,22,33`的内存地址（两个变量指向这个内存，引用计数器为2）
- 由函数执行完毕之后，函数内部的变量都会被释放（删除data变量，内存地址的引用计数器-1）

所以最终v1指向的函数内部创建的那块内存地址

  
引用计数器（Reference Counter）是一种用于跟踪程序中对象引用（指向内存中对象的指针或引用）数量的技术。它是一种用于自动内存管理的方法，主要用于编程语言和运行时环境，以帮助管理动态分配的内存，确保在不再需要对象时释放该对象的内存。

引用计数器的基本原理是为每个对象维护一个计数器，该计数器记录了指向该对象的引用数量。当一个新引用指向对象时，引用计数增加，当引用被销毁或不再指向对象时，引用计数减少。一旦引用计数减少到零，表示没有任何引用指向该对象，系统可以安全地回收该对象占用的内存。

引用计数器的优点包括：

1. **实时回收：** 引用计数允许在不再需要对象时立即释放内存，而不需要等待垃圾收集器运行。
    
2. **简单：** 实现相对简单，因为它只涉及引用计数的增加和减少。
    

然而，引用计数器也存在一些缺点，包括：

1. **无法解决循环引用：** 引用计数不能很好地处理循环引用，当两个或多个对象相互引用时，它们的引用计数永远不会降为零，因此这些对象将无法被垃圾回收。
    
2. **性能开销：** 在每次引用的增加和减少时都需要维护计数器，这可能会引入一些性能开销。
    
3. **不适合多线程：** 引用计数在多线程环境中需要额外的同步操作，以避免竞态条件和数据不一致。
    

由于引用计数的局限性，许多现代编程语言和运行时环境采用了更高级的垃圾回收技术，例如基于标记-清除、分代回收或引用图的垃圾收集器，以解决循环引用和提高性能。然而，在某些情况下，引用计数仍然可以作为内存管理的一部分，例如辅助其他垃圾回收技术。

如果这个时候重新执行一次函数
```python
def func():  
    data = [11, 22, 33]  
    return data  
  
v1 = func()  
print(v1) # [11,22,33]

v2 = func()  
print(v2) # [11,22,33]
```
这时候的执行过程：
- 执行func函数
- `data = [11,22,33]`创建一块内存区域，内部储存`[11,22,33`，data变量指向这块内存地址
- `return data` 返回data指向的内存地址
- v1 接收返回值，所以v1和data都指向`[11,22,33`的内存地址（两个变量指向这个内存，引用计数器为2）
- 由函数执行完毕之后，函数内部的变量都会被释放（删除data变量，内存地址的引用计数器-1）

所以最终v1指向的函数内部创建的那块内存地址

- 执行func函数
- 使用data创建要给内存区域
- return data 返回data的内存区域
- v2接收返回值，所以v2和这个时候的data都指向同一个内存，引用计数器为2
- 函数执行完毕后，函数内部的变量都会释放，引用计数器-1

```python
def func():  
    data = [11, 22, 33]  
    return data  
  
v1 = func()  
print(v1) # [11,22,33]

v2 = func()  
print(v2) # [11,22,33]
# 2343349851584  
# 2343349851584  
# 2343349850624  
# 2343349850624
```

如果函数中的数据是一个str这种不可变的数据类型，这时候输出 的内存地址是一样的
因为python中的缓存和驻留机制，是一种内部优化机制
他会由一些他认为经常使用的数据，会保存一个缓存区域
Python 中有两个与对象缓存和驻留相关的机制：**对象缓存（Object Caching）**和**字符串驻留（String Interning）**。

1. **对象缓存（Object Caching）**：

   Python 在内部维护一个对象缓存池，它用于存储并重复使用一些不可变对象，例如整数和小的字符串。这个机制被用来节省内存，因为相同的对象只会在内存中存在一份副本，多个变量可以引用同一个对象。

   举例来说，当你创建多个整数变量并赋予它们相同的值时，它们实际上会引用相同的整数对象：

   ```python
   a = 42
   b = 42
   ```

   在这个示例中，`a` 和 `b` 实际上引用了相同的整数对象，因为Python会在对象缓存中查找是否已经存在值为42的整数对象，如果存在就重复使用它。

2. **字符串驻留（String Interning）**：

   字符串驻留是一种机制，Python 在运行时会缓存和重复使用具有相同内容的字符串。Python 为较短的字符串（通常长度在0到20之间）进行驻留，以节省内存。这是通过使用一个字符串池来实现的，以便多个变量可以共享相同内容的字符串，而不是创建多个副本。

   举例来说，如果你创建两个具有相同内容的字符串：

   ```python
   a = "hello"
   b = "hello"
   ```

   `a` 和 `b` 将引用相同的字符串对象，因为Python会自动驻留这些短字符串。

需要注意的是，这些机制通常对于不可变对象有效，对于可变对象（如列表、字典）通常不适用。此外，驻留和缓存机制是Python的内部优化，通常不需要显式地处理，而是由解释器自动管理。

你可以使用 `sys` 模块中的 `sys.getrefcount()` 函数来检查对象的引用计数，以了解对象是否已被缓存。然而，这通常用于调试目的，而不是正常的应用程序开发。