### 1.3 参数的默认值

```python
def func(a1,a2=18):  
    print(a1,a2)
```

原理：python在创建函数（未执行）时，如果发现函数的参数中有默认值，则在函数内部会创建一块区域并维护这个默认值

- 执行函数未传值时候，则让a2指向函数维护那个值的地址
```python
func("root")
```
- 执行函数传值的时候，让a2指向新传入的值的地址
```python
func("admin",20)
```

在特定情况【默认函数的值是可变类型】&【函数内部会修改这个值】下，函数的默认值

- 坑
```python
def func(a1,a2=[1,2]):
	a2.append(666)
	print(a1,a2)

func(100)
func(200)
func(99,[77,88])
func(300)
```
这里坑是因为使用a2的默认值是一个列表
这个时候的执行过程是：
- 执行函数func，传入a1的参数，创建a2的默认值的一个储存空间
- 将a2指向的储存空间变为另一个列表1，2，666
- 以后每次执行一次函数，因为列表指向的储存空间可变，所以会不断的添加666在列表中间，执行多少次添加多少次


- 大坑
```python
def func(a1,a2=[1,2]):
	a2.append(a1)
	return a1

v1 = func(10)
print(v1)

v2 = func(20)
print(v2)

v3 = func(30, [11,22])
print(v3)

v4 = func(40)
print(v4)
```

运行的过程是：
这个代码中的函数 `func` 接受两个参数 `a1` 和 `a2`，其中 `a2` 具有默认值 `[1, 2]`，而 `a1` 没有默认值。以下是每次函数调用的流程：

1. 第一个函数调用 `v1 = func(10)`：
   - `a1` 被赋值为 10。
   - `a2` 使用默认值 `[1, 2]`。
   - 在函数内部，`a2.append(a1)` 将 10 添加到 `a2` 列表中，结果是 `a2` 变成 `[1, 2, 10]`。
   - 函数返回 `a1`，所以 `v1` 的值为 10。

2. 第二个函数调用 `v2 = func(20)`：
   - `a1` 被赋值为 20。
   - `a2` 使用默认值 `[1, 2]`。
   - 在函数内部，`a2.append(a1)` 将 20 添加到 `a2` 列表中，结果是 `a2` 变成 `[1, 2, ,10, 20]`。
   - 函数返回 `a1`，所以 `v2` 的值为 20。

3. 第三个函数调用 `v3 = func(30, [11, 22])`：
   - `a1` 被赋值为 30。
   - `a2` 被显式传递为 `[11, 22]`，覆盖了默认值 `[1, 2]`。
   - 在函数内部，`a2.append(a1)` 将 30 添加到 `a2` 列表中，结果是 `a2` 变成 `[11, 22, 30]`。
   - 函数返回 `a1`，所以 `v3` 的值为 30。

4. 第四个函数调用 `v4 = func(40)`：
   - `a1` 被赋值为 40。
   - `a2` 使用默认值 `[1, 2]`。
   - 在函数内部，`a2.append(a1)` 将 40 添加到 `a2` 列表中，结果是 `a2` 变成 `[1, 2, 10, 20, 40]`。
   - 函数返回 `a1`，所以 `v4` 的值为 40。

需要注意的是，由于在函数定义中使用了默认的可变列表 `[1, 2]`，这导致每次函数调用都会影响到默认列表的内容，因为它在函数内部被修改。如果您希望避免这种共享默认列表的情况，可以按照之前的回答中的建议修改函数，以在需要时创建一个新的列表。


- 深坑

```python
def func(a1, a2=[1, 2]):  
    a2.append(a1)  
    return a2  
  
v1 = func(10)  
v2 = func(20)  
v3 = func(30, [11,22])  
v4 = func(40)  
  
print(v1, v2, v3, v4)   
# [1, 2, 10, 20, 40] [1, 2, 10, 20, 40] [11, 22, 30] [1, 2, 10, 20, 40]
```

参数传递的过程是：

1. v1的操作流程
- 创建一个默认的列表空间`[1,2]`
- 传入a1的值10，然后append到列表空间改变了值`[1,2,10]`
- v1指向这个值存在的空间中

2. v2的操作流程
- 指向默认的列表空间
- 传入20，添加到列表存在的内存中改变值`[1,2,10,20]`
- v2指向这个值存在的空间中

如下同理直到列表空间中值变为`[1,2,10,20,40]`
这时候因为返回值是内存空间，所以返回值都是一样的

