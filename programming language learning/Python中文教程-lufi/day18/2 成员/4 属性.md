属性其实是由绑定方法 + 特殊装饰器 组合创造出来的,以后再调用的时候可以不用加括号,例如
```python
class Foo(object):  
  
    def __init__(self,name):  
        self.name = name  
  
    def f1(self):  
        return 123  
  
    @property  
    def f2(self):  
        return 123  
  
obj = Foo("wupeiqi")  
  
v1 = obj.f1()  
print(v1)  
  
v2 = obj.f2  
print(v2)
```

属性并不是特别重要,因为python中没有它,也不影响编写代码
作用是让代码简单一些
我们写代码的时候应用不是很广泛
但是可以帮助我们读别人的源码的时候直到执行过程

类似我们的绑定方法,但是会在绑定方法上边添加一个装饰器@property
使用这个方法之后,以后调用这个方法的时候,就不需要添加括号了

```python
# 之前开发过的分页功能  
class Pagination:  
    def __init__(self, current_page, per_page_num=10):  
        self.per_page_num = per_page_num  
  
        if not current_page.isdecimal():  
            self.current_page = 1  
            return  
        current_page = int(current_page)  
        if current_page < 1:  
            self.current_page = 1  
            return  
        self.current_page = current_page  
  
    @property  
    def start(self):  
        return (self.current_page - 1) * self.per_page_num  
  
    def end(self):  
        return self.current_page * self.per_page_num  
  
user_list = [f"用户-{i}" for i in range(1, 3000)]  
  
# 分页显示,每页显示10条  
while True:  
    page = input("请输入页码:")  
  
    # page, 当前访问的页码  
    # 10 每页显示的10条数据  
    # 内部执行的Pagination类的init方法  
    pg_object = Pagination(page,20)  
  
    page_data_list = user_list[pg_object.start:pg_object.end()]  
    for item in page_data_list:  
        print(item)
```

可以看到这里使用start前面添加装饰器@property
在后边调用start方法的时候,就可以不用添加括号

像是requests模块中也有@property
```python
import requests
from requests.models import Response

# 内部下载视频,并将下载好的数据分装到Response对象中
# res = Response(....)
res = requests.get(
	url = url
	headers = {
	
	}
)

print(type(res)) # requests.model.Response
# 这个结果打印出来的是一个类名字如上
# 可以查看类中间含有什么方法
```
![[Pasted image 20231030224321 1.png]]
发现是有@property装饰器的


关于属性的编写有两种方式:
- 方式一,基于装饰器
```python
class C(object):  
  
    # 就是类的绑定方法上边加上装饰器property  
    # 直接执行方法名称可以调用方法  
    # 返回值是什么,得到的就是什么  
    @property  
    def x(self):  
        pass  
  
    # 另外两种写法  
    # 方法名.setter, 后边必须要有参数  
    # 以后通过对象.方法名 = 变量,就会找到x这个方法,并且上边装饰器必须是x.setter,并且会传递123到value  
    @x.setter  
    def x(self,value):  
        pass  
    # 装饰器是x.deleter,也是一样的功能  
    @x.deleter  
    def x(self):  
        pass  
  
  
obj = C()  
obj.x  
obj.x = 123  
del obj.x
```

- 方法二,基于定义变量
```python
class C(object):  
  
    def getx(self):  
        pass  
  
    def setx(self,value):  
        pass  
  
    def delx(self):  
        pass  
  
    x = property(getx,setx,delx,"I'm the 'x' property.")  
  
obj = C()  
  
obj.x  
obj.x = 123  
del obj.x
```
如果执行obj.x语法,就会执行getx的方法
如果是obj.x = 123,就会执行setx的方法
如果语法是del obj.x,就会执行delx的方法

如果不想要就替换成None
```python
class C(object):  
  
    def getx(self):  
        pass  
  
    def setx(self,value):  
        pass  
  
    def delx(self):  
        pass  
  
    x = property(getx,None,delx,"I'm the 'x' property.")  
  
obj = C()  
  
obj.x  
obj.x = 123  
del obj.x
```
这时候,第二个就不会被property

Django源码:
```python
class WSGIRequest(HttpRequest):
    def __init__(self, environ):
        script_name = get_script_name(environ)
        # If PATH_INFO is empty (e.g. accessing the SCRIPT_NAME URL without a
        # trailing slash), operate as if '/' was requested.
        path_info = get_path_info(environ) or '/'
        self.environ = environ
        self.path_info = path_info
        # be careful to only replace the first slash in the path because of
        # http://test/something and http://test//something being different as
        # stated in https://www.ietf.org/rfc/rfc2396.txt
        self.path = '%s/%s' % (script_name.rstrip('/'),
                               path_info.replace('/', '', 1))
        self.META = environ
        self.META['PATH_INFO'] = path_info
        self.META['SCRIPT_NAME'] = script_name
        self.method = environ['REQUEST_METHOD'].upper()
        # Set content_type, content_params, and encoding.
        self._set_content_type_params(environ)
        try:
            content_length = int(environ.get('CONTENT_LENGTH'))
        except (ValueError, TypeError):
            content_length = 0
        self._stream = LimitedStream(self.environ['wsgi.input'], content_length)
        self._read_started = False
        self.resolver_match = None

    def _get_scheme(self):
        return self.environ.get('wsgi.url_scheme')

    def _get_post(self):
        if not hasattr(self, '_post'):
            self._load_post_and_files()
        return self._post

    def _set_post(self, post):
        self._post = post

    @property
    def FILES(self):
        if not hasattr(self, '_files'):
            self._load_post_and_files()
        return self._files

    POST = property(_get_post, _set_post)

```
这里最后FILES是一种属性方式
property,里面会把`_get_post, _set_post`这两个方法定义属性
del就是删除属性的


## 补充

由于属性和实例变量的调用方式相同,所以编写的时候注意,属性名称和实例变量不能重名
```python
class Foo(object):

    def __init__(self, name, age):
        self.name = name
        self.age = age

    @property
    def func(self):
        return 123


obj = Foo("吴佩琦", 123)
print(obj.name)
print(obj.func)
```

一旦重名就可能报错
```python
class Foo(object):

    def __init__(self, name, age):
        self.name = name  # 报错,认为你想要调用@name.setter装饰的方法
        self.age = age

    @property
    def name(self):
        return "{}-{}".format(self.name, self.age)


obj = Foo("无阿脾气", 123)
```
因为这里有个等式,所以他就会找那个name.setter的装饰器属性,所以会报错

```python
class Foo(object):

    def __init__(self, name, age):
        self.name = name 
        self.age = age

    @property
    def name(self):
        return "{}-{}".format(self.name, self.age) # 报错,循环调用自己(直到层级太深)

    @name.setter
    def name(self, value):
        print(value)


obj = Foo("吴佩琦", 123)
print(obj.name)
```
只要有等式,就调用哪个setter的装饰器的方法
通过对象执行name,就会继续调用name
在你的代码中，无限循环是发生在 `name` 属性的 `@property` getter 方法中。具体来说，这里发生了递归调用：

1. `obj.name` 被访问。
2. 进入 `name` 属性的 getter 方法，`self.name` 被访问。
3. 由于 `self.name` 又触发了 `obj.name`，再次访问 `obj.name`。
4. 此时，程序返回到第2步，导致无限循环。

这个问题的根本原因是属性名称 `name` 既被用作存储属性也被用作 `@property` getter 方法，导致了递归调用。要解决这个问题，需要将属性名称与存储属性的名称不同，如我在之前的回答中所示。


如果想要名字中有关联
```python
class Foo(object):

    def __init__(self, name, age):
        self._name = name  # 使用下划线前缀，约定为私有属性
        self.age = age

    @property
    def name(self):
        return "{}-{}".format(self._name, self.age)

    @name.setter
    def name(self, value):
        print(value)

obj = Foo("吴佩琦", 123)
print(obj.name)

```
