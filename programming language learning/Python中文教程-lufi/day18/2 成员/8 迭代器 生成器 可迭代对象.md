- `__iter__`
	- 迭代器
```python
# 迭代器类型的定义:  
# 1. 当类中定义了 __iter__ 和 __next__两个方法  
# 2. __iter__方法需要返回对象本身,即:self  
# 3. __next__方法,返回下一个数据,如果没有数据了,就需要抛出一个StopIteration异常  
# 官方文档 https://docs.python.org/3/library/index.html  
# 创建迭代器类型:  
class IT(object):  
    def __init__(self):  
        self.counter = 0  
  
    def __iter__(self):  
        return self  
  
    def __next__(self):  
        self.counter += 1  
        if self.counter == 3:  
            raise StopIteration()  
        return self.counter  
  
# 根据类实例化创建一个迭代器对象:  
obj1 = IT()  
  
v1 = next(obj1) # obj1.__next__()  
print(v1)  
  
v2 = next(obj1)  
print(v2)  
  
v3 = next(obj1)  
print(v3)  
  
obj2 = IT()  
for item in obj2:  
    print(item)  
  
# 迭代器对象支持通过next取值,如果取值结束就自动抛出StopIteration  
# for循环在内部循环的时候,先执行__iter__方法,获取一个迭代器对象,然后不断执行的next取值(有异常就StopIteration终止循环)
```
- 首先在类中定义两个方法 `__iter__ __next__`
- `__iter__`中返回值是self
- `__next__`方法中写一个 += 1的算法, 然后满足一种条件之后StopIteration,返回的是每次的计数器

**迭代器的特点**
```python
v1 = obj1.__next__() # counter +1
v2 = obj1.__next__() # +1 基础上 +1,直到=3抛出异常
```
可以使用next方法反复获得迭代器中的数据
也支持for循环, 首先执行迭代器中的`__iter__`方法,也就是self,返回的是这个obj对象,for循环会一直反复执行对象.next方法,每执行一次,就会把结果赋值给item并不断覆盖,所以如果想要储存,最好是使用类,装饰器,列表等等等这些内容储存数据

for循环其实是依赖于迭代器的
开发过程中其实很少自己创建迭代器对象

- 生成器
```python
# 生成器  
# 创建生成器函数:  
def func():  
    yield 1  
    yield 2  
  
# 创建生成器对象(内部是根据生成器类generator创建的对象),生成器类的内部也声明了:__iter__, __next__方法  
obj1 = func()  
  
v1 = next(obj1)  
print(v1)  
  
v2 = next(obj1)  
print(v2)  
  
v3 = next(obj1)  
print(v3)  
  
obj2 = func()  
for item in obj2:  
    print(item)  
  
# 如果按照迭代器的规定来看,其实生成器类也是一种特殊的迭代器
```
生成器对象在创建的时候
会调用python内部的一个类generator,会创建一个生成器对象,这个生成器类的内部也有`__iter__`,`__next__`的方法,并且完全符合迭代器的定义规则


- 可迭代对象
```python
# 可迭代对象  
# 如果一个类中有__iter__方法且返回一个迭代器对象;则我们称以这个类创建的对象为可迭代对象  
class Foo(object):  
  
    def __iter__(self):  
        return "迭代器对象/生成器对象"  
  
obj = Foo() # obj就是可迭代对象  
  
# 可迭代对象是可以使用for循环来进行循环的,在循环的内部实际上是先执行__iter__方法,获取其迭代器对象,然后再在内部执行这个迭代器对象的next功能,逐步取值  
#  
for item in obj:  
    pass  
  
# 创建一个迭代器类  
class IT(object):  
  
    def __init__(self):  
        self.counter = 0  
  
    def __iter__(self):  
        return self  
  
    def __next__(self):  
        self.counter += 1  
        if self.counter == 3:  
            raise StopIteration()  
        return self.counter  
  
# 这个类中返回值是一个迭代器对象  
class Foo(object):  
    def __iter__(self):  
        return IT()  
  
obj = Foo() # 这个是可迭代对象,内部会先执行obj.__iter__并获取迭代器对象，不断的执行迭代器对象的next方法  
for item in obj:  
    print(item)  
  
"""  
之前有说过range功能  
可以创建一个范围的数，但是并不是同时写入内存中，而是生成可迭代对象，因为没有__next__方法，只有__iter__方法  
"""  
  
# 基于可迭代对象&迭代器实现:自定义range  
class IterRange(object):  
    def __init__(self,num):  
        self.num = num  
        self.counter = -1  
  
    def __iter__(self):  
        return self  
  
    def __next__(self):  
        self.counter += 1  
        if self.counter == self.num:  
            raise StopIteration()  
        return self.counter  
  
class Xrange(object):  
    def __init__(self,max_num):  
        self.max_num = max_num  
  
    def __iter__(self):  
        return IterRange(self.max_num)  
  
obj = Xrange(100)  
  
for item in obj:  
    print(item)  
  
"""  
首先是执行并生成一个可迭代对象obj，是Xrange这个类实例化来的  
首先会传参max_num = 100在内存中维护，然后运行iter方法，使用参数  
IterRange是一个迭代器对象，执行的时候先传参给init方法，在IterRange执行中建立num = 100 counter = -1  
接下来执行iter方法，返回self也就是obj  
for循环就是不行执行__next__，但是Xrange里面没有，就去IterRange找，有，就把维护的counter开始 + 1进入判断  
直到循环结束到满足if条件就raise一个StopIteration  
"""  
  
class Foo(object):  
    def __iter__(self):  
        yield 1  
        yield 2  
  
obj = Foo()  
for item in obj:  
    print(item)  
# 注意这里是基于生成器对象来实现的可迭代对象  
# 本质上还是在生成器的时候，也就是yield就去python内置的generator父类中调用方法iter和next  
# 没啥区别  
  
# 基于可迭代对象&生成器，实现自定义range  
class Xrange(object):  
    def __init__(self,max_num):  
        self.max_num = max_num  
  
    def __iter__(self):  
        counter = 0  
        while counter < self.max_num:  
            yield counter  
            counter += 1  
  
obj = Xrange(100)  
for item in obj:  
    print(item)
```
![[Pasted image 20231031144628.png]]
这里v1是可迭代对象,v2是迭代器对象

可迭代的数据类型
```python
# 常见的和这些相关的数据类型  
v1 = list([11,22,33,44]) # 是一个可迭代对象，因为在列表中声明了一个__iter__方法，但是没有next  
# 要检查就调用v1.__iter__()来看是否有next  
# 元组字典集合常规的都是可迭代对象  
# 用代码也可以判断  
  
from collections.abc import Iterator, Iterable  
  
v3 = [11,2,233]  
print(isinstance(v1,Iterator)) # False 判断是否是迭代器：判断依据是iter和next  
print(isinstance(v1, Iterable)) # True 判断是否是可迭代对象：判断依据是是否有iter并且返回迭代器对象  
  
v4 = v3.__iter__()  
print(isinstance(v4, Iterable)) # True  
print(isinstance(v4, Iterator)) # True
```
