1. 面向对象编程中的成员
	- 变量
		- 实例变量
		- 类变量
	- 方法
		- 绑定方法
		- 类方法
		- 静态方法
	- 属性

2. 成员修饰符
3. 对象中的数据嵌套
4. 特殊成员
5. 重要概念：
	- 迭代器
	- 生成器
	- 可迭代对象


## 作业

```python
# 1. 列举面向对象的成员并简述他们的特点  
"""  
- 变量  
    - 实例变量，属于对象。每个对象中都封装各自的值，只能通过的对象来进行调用  
    - 类变量，属于类。每个类中各自保存的数据。可以通过对象和类来进行读取  
  
- 方法  
    - 绑定方法，默认有一个self参数，由对象进行调用（此时的self就等于调用方法的这个对象）【对象&类均可调用】  
    - 类方法，默认有cls参数，用类或者对象都可以调用（此时cls就等于调用方法的这个类）【对象&类均可调用】  
    - 静态方法，无默认参数，用类和对象都可以调用【对象&类均可调用】  
  
- 属性  
    基于方法+property装饰器实现可以实现，  
        obj.属性名  
        obj.属性名 = 123        del obj.属性名  
    语法和方法的对应关系  
"""  
  
# 2. @staticmethod和@classmethod的作用是什么?  
"""  
@classmethod,将一个方法变换类方法:类和方法都可以调用,且cls默认是当前执行该方法的类  
@staticmethod, 将一个方法变换为静态方法,静态方法的调用可以是类也可以对象,无默认参数  
"""  
  
# 3. 面向对象中如何让成员变为私有  
"""  
__成员名  
"""  
  
# 4. __new__方法的作用  
"""  
执行在init方法之前,用于创建一个空对象  
init是方法执行前传入数据  
"""  
  
# 5. 迭代器,生成器,可迭代对象的理解  
"""  
迭代器,含有__iter__方法和__next__方法,__iter__返回自身,__next__可以获得数据(终止是抛出StopIteration异常,可以被for循环)  
生成器,在定义的时候是函数中包含有yield就是生成器函数,执行函数获得生成器对象(一种特殊的迭代器);可以通过next取值,本质上跟迭代器处理机制是一样的  
可迭代对象,含有__iter__方法,并且返回一个迭代器对象,可以for循环  
常见的可迭代对象:list dict set  
"""
```

```python
# 6. 看代码写结果  
class Foo(object):  
    a1 = 1  
  
    def __init__(self,num):  
        self.num = num  
    def show_data(self):  
        print(self.num + self.a1)  
  
obj1 = Foo(666)  
obj2 = Foo(999)  
  
print(obj1.num)  
print(obj1.a1)  
  
obj1.num = 18  
obj1.a1 = 99  
  
print(obj1.num)  
print(obj1.a1)  
  
print(obj2.a1)  
print(obj2.num)  
print(obj2.num)  
print(Foo.a1)  
print(obj1.a1)
```
过程：
- 使用obj1和obj2来接收实例化的Foo类，并且存入num = 666/999
- 在obj中取到封装的num，执行obj.a1在类中找到1
- 然后改变了obj.num=18，并且创建了obj中的a1 = 99
- obj2中num=999,然后类中找a1=1
- Foo类中访问a1也是1
- obj1因为创建了99,所以得到了99

```python
# 7. 看代码写结果,注意返回值  
class Foo(object):  
  
    def f1(self):  
        return 999  
  
    def f2(self):  
        v = self.f1()  
        print('f2')  
        return v  
  
    def f3(self):  
        print('f3')  
        return self.f2()  
  
    def run(self):  
        result = self.f3()  
        print(result)  
  
obj = Foo()  
v1 = obj.run()  
print(v1)
```
过程:
- 实例化Foo类的实例对象obj,执行run方法
- 首先执行f3函数,打印 f3 ,把返回值赋值给result
- 返回值是执行f2的结果,执行f2,首先v赋值f1的返回值999,v=999
- 打印 f2 ,返回值999,然后一路返回给result
- 打印result = 999
- 最后因为run没有返回值,所以v1=None,打印None

```python
# 8. 看代码写结果 有错误标注出来,并假设报错可以执行  
class Foo(object):  
  
    def f1(self):  
        print('f1')  
  
    @staticmethod  
    def f2():  
        print("f2")  
  
obj = Foo()  
obj.f1()  
obj.f2()  
  
Foo.f1()  
Foo.f2()
```
这里使用类执行绑定方法的时候,self需要指定对象传递,需要指定一个self


```python
# 9. 看代码写结果 有错误标注出来,并假设报错可以执行  
class Foo(object):  
      
    def f1(self):  
        print('f1')  
        self.f2()  
        self.f3()  
          
    @classmethod  
    def f2(cls):  
        print('f2')  
          
    @staticmethod  
    def f3():  
        print('f3')  
          
obj = Foo()  
obj.f1()
```
过程:
- 实例化对象obj
- 执行f1,打印f1,调用f2,调用自己打印f2
- 调用f3,打印f3

```python
# 10. 看代码写结果 有错误标注出来,并假设报错可以执行  
class Base(object):  
    @classmethod  
    def f2(cls):  
        print("f2")  
  
    @staticmethod  
    def f3():  
        print("f3")  
  
class Foo(Base):  
    def f1(self):  
        print('f1')  
        self.f2()  
        self.f3()  
  
obj = Foo()  
obj.f1()
```
过程:
- 实例化Foo,执行f1
- 输出f1, 执行f2,自己类没有在父类找
- 打印f2,然后继续f3父类中调用

```python
# 11. 看代码写结果  
class Foo(object):  
    a1 = 1  
    __a2 = 2  
  
    def __init__(self, num):  
        self.num = num  
        self.__salary = 1000  
  
    def show_data(self):  
        print(self.num + self.a1)  
  
obj = Foo(666)  
  
print(obj.num)  
print(obj.a1)  
print(obj.__salary)  
print(obj.__a2)  
print(Foo.a1)  
print(Foo.__a2)
obj.show_data()
```
过程:
- 实例化对象,在init中存了两个值,一个num,一个预定义的__salary=1000
- num,a1都可以拿到,私有的成员都拿不到
- show.data也是可以执行并且调用变量的,`__a2`可以调用但是salary不行


```python
# 12 看代码写结果  
class Foo(object):  
  
    def __init__(self,age):  
        self.age = age  
  
    def display(self):  
        print(self.age)  
  
data_list = [Foo(8), Foo(9)]  
print(data_list[0].age)  
data_list[1].display()  
  
for item in data_list:  
    print(item.age, item.display())
```

- 列表中放着实例化的两个对象,不是用变量名,放在列表里面就用索引代指内存地址
- 这两个对象内部封装有.age
- 这两个对象都是能够调用公有成员的
- for循环中,会先打印一个8,然后display中打印8,然后返回值是None,这三个都要打印

```python
# 13. 看代码写结果  
class Base(object):  
    def __init__(self, a1):  
        self.a1 = a1  
  
    def f2(self, arg):  
        print(self.a1, arg)  
  
class Foo(Base):  
    def f2(self, arg):  
        print('666')  
  
obj_list = [Base(1), Foo(2), Foo(3)]  
obj_list[0].a1 # 1  
obj_list[0].f2(123) # 1,123  
obj_list[1].a1 # 2  
obj_list[1].f2(123) # 666  
  
  
for item in obj_list:  
    item.f2(1)
```

- 列表中存放两类对象,注意封装的init方法中的a1值是不一样的
- 执行的时候注意对象中都有f2,优先在本类中寻找
- 执行中首先找到Base创建的对象,a1=1,调用Base中的f2,打印结果1,1
- 第二个是Foo对象a1=2,用Foo中的f2打印666
- 第三个是a1 = 3,打印666

```python
# 14. 看代码写结果  
class Foo(object):  
    def __init__(self,num):  
        self.num = num  
          
v1 = [Foo for i in range(10)]  
v2 = [Foo(5) for i in range(10)]  
v3 = [Foo(i) for i in range(10)]  
  
print(v1)  
print(v2)  
print(v3)
```
- 第一个是类名循环10次,就是10次指向内存地址
- 第二个是类执行传入num=5,实例化的对象循环10次
- 第三个是i=0,num=0,i=1,num=1,实例化对象10次,但是num不一样

```python
# 15. 看代码写结果  
class StartkConfig(object):  
      
    def __init__(self,num):  
        self.num = num  
      
    def changelist(self, request):  
        print(self.num, request)  
          
config_obj_list = [StartkConfig(1), StartkConfig(2), StartkConfig(3)]  
for item in config_obj_list:  
    print(item.num)
```
- 列表中是实例化对象,储存的num值不一样
- 取值就是123


```python
# 16. 看代码写结果  
class StarkConfig(object):  
  
    def __init__(self,num):  
        self.num = num  
  
    def changelist(self,request):  
        print(self.num, request)  
  
config_obj_list = [StarkConfig(1), StarkConfig(2), StarkConfig(3)]  
for item in config_obj_list:  
    item.changelist(666)
```
- 每次循环的时候执行change666方法
- 结果是1,666 2,666 3,666

```python
# 17. 看代码写结果  
class StarkConfig(object):  
  
    def __init__(self,num):  
        self.num = num  
  
    def changelist(self,request):  
        print(self.num, request)  
  
    def run(self):  
        self.changelist(999)  
  
class RoleConfig(StarkConfig):  
  
    def changelist(self,request):  
        print(666,self.num)  
  
class AdminSite(object):  
    def __init__(self):  
        self._register = {}  
  
    def register(self,k,v):  
        self._register[k] = v  
  
site = AdminSite()  
site.register('wupeiqi',StarkConfig(19))  
site.register('root',StarkConfig(20))  
site.register('admin',RoleConfig(33))  
  
print(len(site._register))  
  
for k,row in site._register.items():  
    row.changelist(5)
```

过程:
- site赋予AdminSite的实例化,定义了一个空字典
- 执行方法register,key=wupeiqi, v = StarkConfig类对象
- 需要传入一个num=19
- site内部放了一个私有的_register的字典,里面是名字对应StarkConfig的对象
- admin是找父类的num=33
- 执行changelist方法的时候需要找对应的方法,前两个是StarkConfig中,最后一个是RoleConfig中
- 所以结果是19 5 20 5 666 33
- 注意这里_不是双下划线,是单下划线,知识区分方法和变量名

```python
# 18. 看代码写结果(如果有报错,标注报错位置)  
class StarkConfig(object):  
  
    def __init__(self,num):  
        self.num = num  
  
    def run(self):  
        self()  
  
    def __call__(self, *args, **kwargs):  
        print(self.num)  
  
class RoleConfig(StarkConfig):  
    def __call__(self, *args, **kwargs):  
        print(345)  
  
    def __getitem__(self, item):  
        return self.num[item]  
  
v1 = RoleConfig('alex')  
v2 = StarkConfig('wupeiqi')  
  
print(v1[1])  
print(v2[2])
```
过程:
- 首先执行v1的实例化,在中间找init,没有在父类找到,传给num=alex
- 然后执行v2的实例化,就正常num=wupeiqi
- 对象用中括号取值,一定需要getitem特殊方法
- v1是有这个方法,等于1=item,alex字符串索引1,就是l
- v2没有这个方法,就报错


```python
# 19. 看代码写结果  
class Department(object):  
    def __init__(self,title):  
        self.title = title  
  
class Person(object):  
    def __init__(self,name,age,depart):  
        self.name = name  
        self.age = age  
        self.depart = depart  
  
    def message(self):  
        msg = f"我是{self.name},年龄{self.age},属于{self.depart}"  
        print(msg)  
  
d1 = Department('人事部')  
d2 = Department('销售部')  
  
p1 = Person('吴佩琦',19,d1)  
p2 = Person('alex',18,d1)  
  
p1.message()  
p2.message()
```
这个在课上有,变量的嵌套有讲

```python
# 20. 分析代码关系,并写出正确的输出结果  
class Node(object):  
    def __init__(self,title):  
        self.title = title  
        self.children = []  
          
    def add(self,node):  
        self.children.append(node)  
          
    def __getitem__(self, item):  
        return self.children[item]  
      
root = Node('中国')  
  
root.add(Node("河南省"))  
root.add(Node("河北省"))  
  
print(root.title)  
print(root[0])  
print(root[0].title)  
print(root[1])  
print(root[1].title)
```

- 实例化root对象,title=中国
- children=空列表,root调用add方法,创建Node对象title=河南省children=空列表,同理对于河北省,就是在第一个children空列表添加两个Node对象
- 调用roottitle的时候,先调用root中的title=中国
- 有getitem方法,所以root0就去找children0,就是第一个title=河南省,children=空列表的对象
- root0中找title就是河南省,同理下面就是河北省

```python
# 21. 分析代码关系,并写出正确的输出结果  
class Node(object):  
    def __init__(self,title):  
        self.title = title  
        self.children = []  
  
    def add(self,node):  
        self.children.append(node)  
  
    def __getitem__(self, item):  
        return self.children[item]  
  
root = Node('中国')  
  
root.add(Node("河南省"))  
root.add(Node("河北省"))  
root.add(Node("陕西省"))  
root.add(Node("山东省"))  
  
root[1].add(Node("石家庄"))  
root[1].add(Node("保定"))  
root[1].add(Node("廊坊"))  
  
root[3].add(Node("潍坊"))  
root[3].add(Node("烟台"))  
root[3].add(Node("威海"))  
  
root[1][1].add(Node("雄安"))  
root[1][1].add(Node("望都"))  
  
  
print(root.title)  
print(root[0].title)  
print(root[1].title)  
print(root[1][0].title)  
print(root[1][2].title)  
print(root[1][1][0].title)  
"""  
中国  
河南省  
河北省  
石家庄  
廊坊  
雄安  
"""
```
没啥区别,就是一层层下去