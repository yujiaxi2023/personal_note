## 相对导入
在导入模块的时候，对于from xx import xx这种模式，还支持相对导入
![[Pasted image 20231026140811.png]]
```python
from . import wechat  
# 找到当前目录找  
from ..utils import encrypt  
# 在上级目录找
```

相对导入只能用在包中的py文件中（即：嵌套在文件中的py文件才可以使用，项目根目录下无法使用
![[Pasted image 20231026140820.png]]


## 导入别名

如果项目中导入导入 成员/模块/包 有重名，那么后导入的会覆盖之前导入的，为了避免这种情况的发生，python支持重命名，即：
```python
from xx.xx import xx as xc
import x1.x2 as pg
```

除此之外，有了as的存在，让import xx.xx.xxx.xx.xx在调用执行的时候会比较简单
- 原来
```python
import commons.page

v1 = commons.page.pagination()
```

- 现在
```python
import commons.page as pg

v1 = pg.pagination()
```

## 主文件

- 执行一个py文件的时候，内部的
```python
__name__ = "__main__"
```
- 导入一个py文件的时候
```python
__name__ = "模块名"
```

下载一个游戏，windows下面，可执行文件就是.exe，也就是入口文件
剩下的就是其他文件，会被入口文件调用

入口文件的作用是执行函数的，其他的文件只会定义函数
拿到一个project，应该从代码的入口去进行分析执行
如果根目录只有1个文件，就是入口文件
如果有多个文件，可以找文件内容，如果只定义了函数，那就是支持文件
如果是run了内容，那就是主文件

主文件，其实就是在程序执行的入口文件，例如：
![[Pasted image 20231026144015.png]]
通常是执行run.py运行程序，其他的py文件都是一些功能代码，当我们执行要给文件的时候，文件内部的__name__变量值为__main__，所以，主文件经常会看到：
```python
import many
from commons import page
from commons import utils

def start():
	v1 = many.show()
	v2 = page.pagination()
	v3 = utils.encrypt()

if __name__ == "__main__":
	start()
```

只有是以主文件的形式运行这个脚本的时候start函数才会执行，被导入的时候不会执行

上面的写法就是主文件，可执行文件的标志
要注意，导入模块或者包的时候，name == 模块名，所以在模块中的执行代码 name == main就会是False，在模块文件中的代码就不会执行

