python内置的模块有很多

## os
文件夹命名,遍历文件夹,创建文件夹,获得路径,路径拼接等等
```python
import os  
  
# listdir  
print(os.listdir(r"C:\Users\student\PycharmProjects\pytut\day14\commons"))  
# ['convert.py', 'import_practice.py', 'module_package.py', 'page.py', 'tencent', 'utils.py', '__init__.py', '__pycache__']  
# pycache是隐藏的文件夹，文件夹套文件夹的文件是找不到的  
  
# walk  
print(os.walk(r"C:\Users\student\PycharmProjects\pytut\day14\commons"))  
# 遍历文件夹下所有的文件 <generator object walk at 0x0000027E8FD6F190> 产生的是生成器  
for item in os.walk(r"C:\Users\student\PycharmProjects\pytut\day14\commons"):  
    print(item)  
  
"""  
('C:\\Users\\student\\PycharmProjects\\pytut\\day14\\commons', ['tencent', '__pycache__'], ['convert.py', 'import_practice.py', 'module_package.py', 'page.py', 'utils.py', '__init__.py'])  
('C:\\Users\\student\\PycharmProjects\\pytut\\day14\\commons\\tencent', ['__pycache__'], ['sms.py', 'wechat.py', '__init__.py'])  
('C:\\Users\\student\\PycharmProjects\\pytut\\day14\\commons\\tencent\\__pycache__', [], ['__init__.cpython-38.pyc'])  
('C:\\Users\\student\\PycharmProjects\\pytut\\day14\\commons\\__pycache__', [], ['convert.cpython-38.pyc', 'page.cpython-38.pyc', 'utils.cpython-38.pyc', '__init__.cpython-38.pyc'])  
"""  
# 每一行是一个元组，元组中有3个元素  
# path folder file这3个列表构成的元组  
# 第二次循环的时候，在下去一个文件夹，tencent，同样的格式  
# 第三次循环，tencent中隐藏文件夹pycache，同样的格式  
# 第四次循环，tencent文件夹中的文件夹找干净了，所以就出去，找commons中的pycache文件夹，同样格式  
# 就是这一步步死磕找干净到只有文件  
# 所以我也可以这样去取值  
for path,folder,file in os.walk(r"C:\Users\student\PycharmProjects\pytut\day14\commons"):  
    for file_name in file:  
        file_abs_path = os.path.join(path,file_name)  
        ext = file_abs_path.rsplit(".",1)[-1]  
        if ext == "py":  
            print(file_abs_path)  
  
  
# 1. 获得当前脚本的绝对路径  
abs_path = os.path.abspath(__file__)  
print(abs_path)  
  
# 2. 获取当前文件的上级目录  
base_path = os.path.dirname(os.path.dirname(r"C:\Users\student\PycharmProjects\pytut\day14\__init__.py"))  
print(base_path)  
  
# 3. 路径拼接  
p1 = os.path.join(base_path,"xx")  
print(p1)  
  
p2 = os.path.join(base_path,"xx","oo","a1.png")  
print(p2)  
  
# 4. 判断路径是否存在  
exists = os.path.exists(p1)  
print(exists)  
  
# 5. 创建文件夹  
os.makedirs(r"C:\Users\student\PycharmProjects\pytut\day14\new")  
  
path = os.path.join(base_path,"xx","oo","uuuu")  
if not os.path.exists(path):  
    os.makedirs(path)  
  
  
# 6. 是否是文件夹  
file_path = os.path.join(base_path, "xx", "pp", "uuuu.png")  
is_dir = os.path.isdir(file_path)  
print(is_dir) # False  
  
folder_path = os.path.join(base_path, "xx", "oo", "uuuu")  
is_dir = os.path.isdir(folder_path)  
print(is_dir) # True  
  
# 7. 删除文件或者文件夹  
os.remove(r"C:\Users\student\PycharmProjects\pytut\day14\__init__.py")  
  
path = os.path.join(base_path, "xx")  
shutil.rmtree(path)
```

## shutil
解压缩包,删除拷贝文件,文件夹
```python
import os  
import shutil  
  
base_path = os.path.dirname(os.path.dirname(r"C:\Users\student\PycharmProjects\pytut\day14\__init__.py"))  
print(base_path)  
  
# 1. 删除文件夹  
path = os.path.join(base_path,"xx")  
shutil.rmtree(path)  
  
# 2. 拷贝文件夹  
shutil.copytree(r"C:\Users\student\PycharmProjects\pytut\day14\bin",r"C:\Users\student\PycharmProjects\pytut\day14\commons")  
  
# 3. 拷贝文件  
shutil.copy(r"C:\Users\student\PycharmProjects\pytut\day14\__init__.py",r"C:\Users\student\PycharmProjects\pytut\day14")  
shutil.copy(r"C:\Users\student\PycharmProjects\pytut\day14\__init__.py",r"C:\Users\student\PycharmProjects\pytut\day14\__init__.py")  
  
  
# 4. 文件或者文佳佳重命名  
shutil.move(r"C:\Users\student\PycharmProjects\pytut\day14\__init__.py",r"C:\Users\student\PycharmProjects\pytut\day14\__ini__.py")  
shutil.move(r"C:\Users\student\PycharmProjects\pytut\day14",r"C:\Users\student\PycharmProjects\pytut\today14")  
  
# 5. 压缩文件  
"""  
# base_name，压缩后的压缩包文件  
# format，压缩的格式，例如 zip tar gztar bztar xztar# root_dir，要压缩的文件夹路径  
"""  
shutil.make_archive(base_name=r"datafile",format="tar",root_dir=r"files")  
  
# 6. 解压文件  
"""  
# filename，要解压的压缩包  
# extract_dir，解压的路径  
# format，压缩文件格式  
"""  
shutil.unpack_archive(filename=r"datafile.tar",extract_dir=r"xxxxx/xo",format="tar")
```

## sys
解释器版本,模块导入等
```python
import sys  
  
# 1. 获取解释器版本  
print(sys.version)  
print(sys.version_info)  
print(sys.version_info.major, sys.version_info.minor, sys.version_info.micro)  
  
# 2. 导入模块路径  
print(sys.path)  
  
# argv,执行脚本的时候，python解释器后边传入的参数  
print(sys.argv)  
# ['C:\\Users\\student\\PycharmProjects\\pytut\\day14\\module\\sysmodule.py']  
# 终端中执行的结果是  
# sysmodule.py  
# 命令行中，如果执行python sysmodul.py 123 444 999 666 wupeiqi  
# 结果是sysmodul.py 123 444 999 666 wupeiqi  
# 等于是后边的也是传入的参数，可以被sys.argv接收  
  
# 例子，实现下载图片的工具  
  
def download_image(url):  
    print("下载图片", url)  
  
def run():  
    # 接收用户传入的参数  
    url_list = sys.argv[1:]  
    for url in url_list:  
        download_image(url)  
  
if __name__ == '__main__':  
    run()
```
- argv,执行脚本的时候,python解释器后边传入的参数


## random
```python
import random  
  
# 1. 获取范围内的随机整数  
v = random.randint(10, 20)  
print(v)  
  
# 2. 获取范围内的随机小数  
v = random.uniform(1, 10)  
print(v)  
  
# 3. 随机抽取一个元素  
v = random.choice([11,2,2913,312,32])  
print(v)  
  
# 4. 随机抽取多个元素  
v = random.sample([11,2,3,4,1,5,12,12], 3)  
print(v)  
  
# 5. 打乱顺序  
data = [1,2,3,4,5,6,7,8,9]  
random.shuffle(data)  
print(data)
```


## hashlib
```python
import hashlib  
  
hash_object = hashlib.md5()  
hash_object.update("wupeiqi".encode('utf-8')) # 需要加密的数据，加密处理得到一个译文  
result = hash_object.hexdigest()  
print(result) # 3209d7849fb1b9e85bb22902edf17cbe  
# md5是无法反解码的密码  
# 如果只这么写密码，也可以知道密文是什么，可以通过撞库撞出来  
# 将全球所有可能出现的密码加密一遍形成一个库  
# 避免撞库出来密码对，需要进行加严  
hash_object = hashlib.md5('iajfsdunjaksdjfasdfasdf'.encode('utf-8'))  
hash_object.update('wupeiqi'.encode('utf-8'))  
result = hash_object.hexdigest()  
print(result) # 3d9b3d88d371143bf93efd766bc3f513  
# 这样反解密码就不好解码出来
```

一般是写个函数弄
```python
def md5(origin,salt="lajdfgkhg\adfl;kaadf"):  
    hash_object = hashlib.md5(salt.encode('utf-8'))  
    hash_object.update(origin.encode('utf-8'))  
    result = hash_object.hexdigest()  
    print(result)
```

## configparser
day9
`configparser` 模块是 Python 标准库中用于处理配置文件的工具，通常用于读取和写入配置信息，如INI文件。这个模块可以让您轻松地处理配置文件，如应用程序设置、服务器配置等。

以下是如何使用 `configparser` 模块的基本介绍：

1. **导入模块**：

   ```python
   import configparser
   ```

2. **创建ConfigParser对象**：

   ```python
   config = configparser.ConfigParser()
   ```

3. **读取配置文件**：

   `config.read(filename)` 方法用于读取配置文件。`filename` 是配置文件的路径。

   ```python
   config.read('config.ini')
   ```

4. **访问配置项**：

   使用 `get(section, option)` 方法可以获取配置项的值。`section` 是配置文件中的章节名称，`option` 是配置项的名称。

   ```python
   value = config.get('section_name', 'option_name')
   ```

5. **写入配置文件**：

   使用 `set(section, option, value)` 方法可以设置配置项的值。如果配置文件不存在，`configparser` 将自动创建文件并写入。

   ```python
   config.set('section_name', 'option_name', 'option_value')
   with open('config.ini', 'w') as configfile:
       config.write(configfile)
   ```

6. **添加新章节和配置项**：

   `add_section(section)` 方法用于添加新章节，`set(section, option, value)` 方法用于添加新的配置项。

   ```python
   config.add_section('new_section')
   config.set('new_section', 'new_option', 'new_value')
   ```

7. **检查配置项和章节是否存在**：

   使用 `has_option(section, option)` 和 `has_section(section)` 方法来检查配置项和章节是否存在。

   ```python
   if config.has_option('section_name', 'option_name'):
       # 配置项存在
   ```

8. **删除配置项和章节**：

   使用 `remove_option(section, option)` 和 `remove_section(section)` 方法来删除配置项和章节。

   ```python
   config.remove_option('section_name', 'option_name')
   config.remove_section('section_name')
   ```

这些是 `configparser` 模块的基本用法。它是一种方便的工具，用于处理和管理配置文件，使应用程序更加灵活和可配置。

## xml
day9