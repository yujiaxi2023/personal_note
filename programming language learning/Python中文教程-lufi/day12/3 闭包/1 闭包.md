闭包，就是将数据封装到一个包（区域之中），使用的时候到里面去取，本质上，闭包是基于函数嵌套搞出来的一个特殊嵌套

- 闭包应用场景1：封装数据防止污染全局
```python
name = "wupeiqi"  
  
def f1():  
    print(name, age)  
  
def f2():  
    print(name, age)  
  
def f3():  
    print(name, age)  
  
def f4():  
    pass
```
这时候没有使用闭包，name在全局变量中
```python
def func(age):  
    name = "wupeiqi"  
  
    def f1():  
        print(name, age)  
  
    def f2():  
        print(name, age)  
  
    def f3():  
        print(name, age)  
  
    f1()  
    f2()  
    f3()  
  
func(123)
```

- 闭包应用场景2：封装数据到一个包中，使用的时候取
```python
def task(arg):  
    def inner():  
        print(arg)  
    return inner  
  
  
v1 = task(11)  
v2 = task(22)  
v3 = task(33)  
  
v1()  
v2()  
v3()
```
- 定义了一个嵌套函数
- 传参11进入task，v1赋值会产生一个task作用域，arg = 11，存在inner函数
- v1赋值为返回值inner
- 传参22进入task中，同样的arg = 22，inner函数
- v2赋值为返回值inner
- 同理v3赋值inner，但是arg=33
- 在执行的时候是执行不同的包，也就是局部作用域中的变量
![[Pasted image 20231020201743.png]]

```python
def task(arg):  
    def inner():  
        print(arg)  
    return inner  
  
inner_func_list = []  
for val in [11,22,33]:  
    inner_func_list.append(task(val))  
  
inner_func_list[0]()  
inner_func_list[1]()  
inner_func_list[2]()
```

- 首先定义一个嵌套函数
- 创建一个用来储存执行函数的列表，传入参数值的列表
- 在列表中就是task任务赋值，创建3个内存空间有不同的arg值
- 调用不同的函数，也就可以有不同的arg值

```python
import requests  
from concurrent.futures.thread import ThreadPoolExecutor  
  
def task(url):  
    res = requests.get(  
        url=url,  
        headers={  
            "user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36 Edg/118.0.2088.46"  
        }  
    )  
    print(res.content)  
  
# 线程池，现在是创建了一个线程池有10个人  
POOL = ThreadPoolExecutor(10)  
  
# 视频信息列表  
video_dict = [  
    ("mimic.mp4", "https://v5-dy-o-abtest.zjcdn.com/cd597ec337dffb60b7e9aa8330fc1a7e/653274fb/video/tos/cn/tos-cn-ve-15/ce00e2ed68f14214ac12ed395afa5c0e/?a=1128&ch=0&cr=0&dr=0&lr=aweme_search_suffix&cd=0%7C0%7C0%7C0&cv=1&br=1644&bt=1644&cs=0&ds=3&ft=E3qLXOAmugPzb2NvjSOTIsnRf1enle-4kSY&mime_type=video_mp4&qs=0&rc=OjRnO2VnaGZnaTc6Zzg3NUBpanI4b2t5M2ZweTMzOmkzM0BhYmExMzAvNTQxXl8vNF5iYSNsMGw0YGRiXl9fLS0yLTBzcw%3D%3D&btag=e00098000&cc=46&dy_q=1697801930&l=20231020193850752B16EEF7EECD03B1F1"),  
    ("dunk.mp4", "https://www.bilibili.com/video/BV1rg4y1v72v?t=0.3"),  
]  
for item in video_dict:  
    print(item[0], item[1])  
    # 线程池取一个人，让人下载视频，执行task函数  
    POOL.submit(task, url=item[1])  
  
# 自动创建3个人，并行的下载视频，这里是不会等的，只要是10个以内的视频，就不会停顿
```
这里是使用多线程下载任务
```python
import requests  
from concurrent.futures.thread import ThreadPoolExecutor  
  
  
# 现在我们希望保存到文件中  
  
def task(url):  
    res = requests.get(  
        url=url,  
        headers={  
            "user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36 Edg/118.0.2088.46"  
        }  
    )  
    print(res.content)  
  
  
# 在执行完了下载之后，python多线程内部会执行的函数  
def outer(file_name):  
    def done(arg):  
        # 视频内容  
        content = arg.result()  
        with open(file_name, mode="wb") as file_object:  
            file_object.write(content)  
    return done  
  
# 线程池，现在是创建了一个线程池有10个人  
POOL = ThreadPoolExecutor(10)  
  
# 视频信息列表  
video_list = [  
    ("mimic.mp4", "https://aweme.snssdk.com/aweme/v1/playwm/?video_id=v0300f570000bvbmace0gvch7lo53oog"),  
    ("dunk.mp4", "https://aweme.snssdk.com/aweme/v1/playwm/?video_id=v0200f3e0000bv52fpn5t6p007e34q1g")  
]  
for item in video_list:  
    # 线程池取一个人，让人下载视频，执行task函数  
    future = POOL.submit(task, url=item[1])  
    # 当执行完成task函数之后，下载完成，自动执行某个函数  
    # 在add_done这里输入一个函数  
    future.add_done_callback(outer(item[0])) # 执行done函数的时候，每个闭包有不一样的名字  
    print(item)  
  
# 自动创建3个人，并行的下载视频，这里是不会等的，只要是10个以内的视频，就不会停顿
```

这里是添加了保存代码，但是因为user-agent可能有问题，也就是header
所以结果执行不出来