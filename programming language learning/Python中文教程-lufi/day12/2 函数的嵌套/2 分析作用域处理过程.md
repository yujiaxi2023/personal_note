基于内存和执行过程分析作用域
```python
name = "wupeiqi"  
  
def run():  
    name = "alex"  
    def inner():  
        print(name)  
    inner()  
      
run()
```
执行过程中的内存情况：
- 全局变量中有name和run作为变量
- 执行run的时候创建空间
- 在局部run的空间中创建变量name和inner函数
- 执行inner函数，局部空间中创建局部空间
- 执行print函数，寻找name变量，在当前作用域没有，去上一级作用域
- 在局部作用域的上一级的局部作用域中可以找到name=alex，输出是alex

![[Pasted image 20231020184938.png]]

```python
name = "wupeiqi"  
  
def run():  
    name = "alex"  
    def inner():  
        print(name)  
    return inner()  
  
v1 = run()  
v1()  
  
v2 = run()  
v2()
```
执行过程中的内存情况：
- 全局作用域中有name和run函数
- v1=run（）的时候会执行run函数，创建一个作用域
- 局部作用域中name和inner函数创建
- return inner的时候，将函数内存地址返回
- v1指向内存地址inner的位置
- v1（）执行inner（），创建局部空间中的局部空间，print了name
- 按理来说执行完了，应该print的数据销毁掉，这个局部作用域中的局部作用域就消失了
- v2=run（）会再创建一个作用域
- 同时创建一个name和inner
- 执行v2（）的时候会执行第二个局部作用域中的inner函数，然后创建一个局部空间print alex，然后作用域删除销毁

![[Pasted image 20231020185908.png]]

```python
name = "wupeiqi"  
  
def run():  
    name = "alex"  
    def inner():  
        print(name)  
    return [inner, inner, inner]  
  
func_list = run()  
func_list[2]()  
func_list[1]()  
  
funcs = run()  
funcs[2]()  
funcs[1]()
```
执行过程 ：
- 全局作用域name和run函数
- func_list = run（）创建局部作用域，局部作用域中创建name和inner函数
- return的是一个列表，包含三个指向inner内存地址的位置
- func_list被指定到内存地址中，所以等于一个列表有3个inner函数
- 执行inner函数，创建局部作用域，在第一个创建的局部作用域中
- 再执行一次inner函数在局部作用域中创建局部作用域
- funcs=run（）同样的是上边的过程，有一个局部作用域下面有两个小的局部作用域
![[Pasted image 20231020190719.png]]

**作用域重点**
- 优先在自己作用域找，没有就去上级找
- 作用域中找值的时候，确保此时此刻值是什么
- 分析函数的执行，确定函数的作用域链（函数嵌套关系）

