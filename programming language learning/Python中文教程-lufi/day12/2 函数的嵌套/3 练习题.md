1. 分析代码写结果
```python
# 分析代码，写结果  
name = "wupeiqi"  
  
  
def func():  
    def inner():  
        print(name)  
  
    res = inner()  
    return res  
  
  
v = func()  
print(v) # wupeiqi none
```
![[Pasted image 20231020191242.png]]
过程：
- 全局name和func
- v赋值func（）也就是返回值，这时先执行func
- 创建局部作用域
- 局部作用域中inner函数
- res赋值inner（）也就是返回值
- 执行inner函数创建小一层级的局部作用域
- 作用域中print name，name在局部中没有，调用全局
- 打印name，返回值默认为none
- res赋值none
- 返回值res
- v赋值res为none
- 结果是wupeiqi none

2. 分析代码写结果
```python
name = "wupeiqi"  
  
  
def func():  
    def inner():  
        print(name)  
        return "alex"  
  
    res = inner()  
    return res  
  
  
v = func()  
print(v)
```
过程：
- 全局name和func
- v准备赋值func返回值
- 执行func创建局部作用域
- 局部作用域储存inner
- res预备赋值inner返回值
- inner执行函数创建下一层级局部作用域
- print name 调用全局变量，打印wupeiqi
- return alex
- res赋值返回值alex
- func返回值res，也是内存地址一样alex
- v赋值res也是alex
- 结果wupeiqi alex

3. 分析代码写结果
```python
name = 'root'  
  
def func():  
    def inner():  
        print(name)  
        return "admin"  
    return inner  
  
v = func()  
result = v()  
print(result)
```
过程：
- 全局作用域name func
- 执行func函数，创建局部作用域
- 局部作用域中inner函数，返回值inner函数的地址
- v赋值给inner地址
- result = v执行函数，也是执行inner
- inner是在func的空间中执行，创建一个下级作用域
- print name的时候调用全局作用域中的name = root 所以打印root
- 返回值admin
- 所以v（）返回值admin，赋值给result
- 打印result也就是admin

4. 分析代码写结果
```python
def func():  
    name = "wupeiqi"  
    def inner():  
        print(name)  
        return "lufei"  
    return inner  
  
v1 = func()()  
print(v1)  
  
v2 = func()()  
print(v2)
```
过程：
- 全局作用域中func函数
- v1 = 预备作为func返回值的执行的返回值
- 首先执行func函数，创建局部作用域
- 局部作用域func中name和inner函数，return inner函数
- v1 就是 inner函数执行返回值
- func作用域中，创建inner作用域，打印name调用上级作用域wupeiqi
- return lufei
- v1 就赋值lufei，打印lufei
- v2 = 再次执行func，创建第二个func作用域
- 第二个func作用域中，inner和name存在然后return inner
- 在inner执行返回lufei并打印wupeiqi
- v2也是lufei

![[Pasted image 20231020193214.png]]

5. 看代码分析结果
```python
def func(name):  
    # name = "alex"  
    def inner():  
        print(name)  
        return "luffy"  
    return inner  
  
v1 = func("wupeiqi")()  
print(v1)  
  
v2 = func("alex")()  
print(v2)
```
过程：
- 全局作用域有func函数
- 执行func函数，传参wupeiqi，func作用域中有name = wupeiqi这个空间，然后又inner函数，return inner变量
- 执行innner函数，在func作用域中又inner作用域，print name，在这里上一级有wupeiqi所以打印
- 返回luffy，打印luffy
- 第二次执行func，传参alex，作用域中有name= alex，然后inner函数，return inner
- 执行inner，同样的打印alex
- 返回luffy赋值v2，打印luffy

![[Pasted image 20231020195359.png]]

```python
def func(name):  
    def inner():  
        print(name)  
        return "luffy"  
    return inner
  
v1 = func("wupeiqi")  
v2 = func("alex")  
v1()  
v2()
```
过程：
- 全局作用域，func函数
- 执行func创建func作用域，有inner，返回inner
- 传参wupeiqi，在func作用域中有name = wupeiqi
- 第二次执行v2的func，创建作用域，传参alex，name = alex
- 执行v1和v2返回的函数innner
- 结果就是v1 wupeiqi，v2 alex

6. 分析代码写结果
```python
def func(name=None):  
    if not name:  
        name = "wupeiqi"  
  
    def inner():  
        print(name)  
        return "root"  
  
    return inner  
  
  
v1 = func()()  
v2 = func("alex")()  
print(v1, v2)
```

过程：
- 全局作用域有func函数
- v1 赋值，首先执行func函数
- func创建一个局部作用域，默认传参name = None
- 在func作用域中，因为name是none，然后not就是true
- name = wupeiqi
- func中间有name = wupeiqi，inner函数
- 返回inner地址
- inner在v1的时候继续执行
- inner在func局部作用域中创建作用域
- print name = wupeiqi，返回值root
- v1赋值root
- v2 赋值，func创建局部作用域，传参name=alex，条件判断跳过
- func第二个作用域中有name = alex，inner函数
- 执行inner函数，创建作用域，里面有name 打印结果alex，返回root
- v2就是root
- 结果就是 wupeiqi alex root root

