编写一个网站的时候，如果项目由100个页面，其中99个是需要登录成功之后才能有权限访问，这就可以基于装饰器来实现
```python
pip install flask
```
进入网站的伪代码
```python
from flask import Flask  
  
app = Flask(__name__)  
  
def auth(func):  
    def inner(*args,**kwargs):  
        # 判断用户是否已经登录，如果已经登录就继续，没有登录就返回登录页面  
        res = func(*args, **kwargs)  
        return res  
  
    return inner  
  
@auth  
def index():  
    return "HOMEPAGE"  
  
@auth  
def info():  
    return "USER_CENTER"  
  
@auth  
def order():  
    return "ORDER_CENTER"  
  
@auth  
def login():  
    return "LOGIN_PAGES"  
  
app.add_url_rule("/index/", view_func=index)  
app.add_url_rule("/info/", view_func=info)  
app.add_url_rule("/order/", view_func=order)  
app.add_url_rule("/login/", view_func=login)  
  
app.run()
```

### 重要补充：functools

装饰器实际上将原函数更改成其他的函数，然后在此函数中调用原函数

```python
def auth(func):  
    def inner(*args,**kwargs):  
        # 判断用户是否已经登录，如果已经登录就继续，没有登录就返回登录页面  
        res = func(*args, **kwargs)  
        return res  
  
    return inner  
  
@auth  
def admin():  
    """  
    这个可以打印123的函数  
    Returns    -------  
    """    print(123)  
  
def rbac():  
    print("rbac")  
  
# 函数名 + () 是一种执行函数的方法  
# 函数名.__name__ 这里获得是字符串形式的函数名  
# 函数名.__doc__ 这里可以获得函数的注释  
admin() # 这个时候执行的函数不是admin，而是outer中的inner，只不过inner会调用上级作用域中储存的函数  
print(admin.__name__) # "admin"，所以现在加了装饰器之后获得的名字就是inner  
print(admin.__doc__) # 这里获得的注释将会是inner中的注释内容  
  
rbac()
```

```python
import functools  
  
  
def auth(func):  
    @functools.wraps(func) # inner.__name__ = func.__name__ inner.__doc = fun.__doc__  
    def inner(*args,**kwargs):  
        # 判断用户是否已经登录，如果已经登录就继续，没有登录就返回登录页面  
        res = func(*args, **kwargs)  
        return res  
  
    return inner  
  
@auth  
def admin():  
    """  
    这个可以打印123的函数  
    Returns    -------  
    """    print(123)  
  
def rbac():  
    print("rbac")  
  
# 函数名 + () 是一种执行函数的方法  
# 函数名.__name__ 这里获得是字符串形式的函数名  
# 函数名.__doc__ 这里可以获得函数的注释  
admin() # 这个时候执行的函数不是admin，而是outer中的inner，只不过inner会调用上级作用域中储存的函数  
print(admin.__name__) # "admin"，所以现在加了装饰器之后获得的名字就是inner  
print(admin.__doc__) # 这里获得的注释将会是inner中的注释内容  
  
rbac()  
  
"""  
这时候就有一个需求  
如果我希望能够知道原来未加装饰器的函数带有的注释要怎么做  
这里可以在inner函数前面加上装饰器functools.wraps  
"""
```