当函数有参数的时候，如果直接使用outer就会报错

```python
"""  
函数有参数的情况  
"""  
def outer(origin):  
    def inner():  
        print("before")  
        res = origin() # 调用原来的func函数并存储到outer空间中  
        print("after")  
        return res  
    return inner  
  
@outer # func_1 = outer(func_1)  
def func_1(a1):  
    print("我是func1函数")  
    value = (11,22,33,44)  
    return value  
  
@outer # func_2 = outer(func_2)  
def func_2(a1,a2):  
    print("我是func2函数")  
    value = (11,22,33,44)  
    return value  
  
@outer # func_3 = outer(func_3)  
def func_3(a1):  
    print("我是func3函数")  
    value = (11,22,33,44)  
    return value  
  
func_1(1)  
func_2(11,22)  
func_3(999)
```
这种情况一定会报错
分析流程：
- 在执行@的时候也就是执行outer函数
- outer函数会返回值inner函数
- inner函数这时候就是func新赋值的内容
- func这个时候就是inner函数，但是这个inner函数比较特殊inner函数这里有传入一个参数origin
- origin是原先传入的func函数，于是outer中有一个空间是origin=func
- 在执行inner的时候，inner函数中包含了res = origin函数，返回值是res
- 也就是返回执行func函数
- 于是这里就是inner在传入参数
- 我们应该要让inner的参数传递到origin中去才能使我们在使用func的时候添加参数的时候能直接执行出参数值

**这时候动态参数就可以派上用场**

```python
"""  
函数有参数的情况  
"""  
def outer(origin):  
    def inner(*args,**kwargs):  
        print("before")  
        res = origin(*args,**kwargs) # 调用原来的func函数并存储到outer空间中  
        print("after")  
        return res  
    return inner  
  
@outer # func_1 = outer(func_1)  
def func_1(a1):  
    print("我是func1函数")  
    value = (11,22,33,44)  
    return value  
  
@outer # func_2 = outer(func_2)  
def func_2(a1,a2):  
    print("我是func2函数")  
    value = (11,22,33,44)  
    return value  
  
@outer # func_3 = outer(func_3)  
def func_3(a1):  
    print("我是func3函数")  
    value = (11,22,33,44)  
    return value  
  
func_1(1)  
func_2(11,22)  
func_3(999)
```
这样就是完全的帮助无论如何有多少参数都可以执行的函数装饰器