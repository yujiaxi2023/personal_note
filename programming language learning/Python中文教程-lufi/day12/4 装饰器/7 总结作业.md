## 总结

1. 函数可以定义在全局，也可以定义在别的函数中（函数的嵌套）
2. 学会分析函数的执行步骤（内存中作用域的管理）
3. 闭包，基于函数的嵌套，可以将数据封装到一个包中，以后再调用
4. 装饰器
- 实现原理：基于@语法和函数闭包，将函数封装在闭包中，然后将函数赋值为一个新的函数（内层函数），执行函数再在内层函数中执行闭包中的原函数
- 实现效果：可以在不改变原函数内部代码和调用方式的前提下，实现函数执行和执行扩展功能
- 适用场景，多个函数系统同一在执行前后自定义一些功能
- 装饰器示例：
```python
def outer(origin):  
    def inner(*args,**kwargs):  
        # 执行前  
        res = origin(*args,**kwargs) # 调用原来的func函数  
        # 执行后  
        return res  
    return inner  
  
  
@outer  
def func(a1):  
    pass  
  
func(1)
```

## 作业

```python
# 1. 请为以下所有函数编写一个装饰器,添加装饰器后可以实现,执行func的时候,先执行func函数内部代码,然后输出after  
"""  
import functools  
  
  
def outer(origin):  
    @functools.wraps(origin)    def inner(*args, **kwargs):        res = origin(*args, **kwargs)        print("after")        return res  
    return inner  
  
@outer  
def func(a1):  
    return a1 + "SB"  
  
@outer  
def base(a1, a2):  
    return a1 + a2 + "SB"  
  
@outer  
def foo(a1, a2, a3, a4):  
    return a1 + a2 + a3 + a4 + "SB""""  
  
# 2. 请为以下所有函数编写一个装饰器,添加上装饰器后可以实现,将被装饰的函数执行5次,每次执行函数的结果按照顺序放到列表中,最终返回列表  
"""  
import random  
import functools  
  
  
def repeat(origin):  
    @functools.wraps(origin)    def inner(times, *args, **kwargs):        data_list = []        for i in range(times):            res = origin(*args, **kwargs)            data_list.append(res)        return data_list  
    return inner  
  
@repeat  
def func():  
    return random.randint(1, 4)  
  
result = func(5)  # 内部执行5次,并将结果追加到列表返回result  
print(result)  
"""  
  
# 3. 请为以下函数编写一个装饰器,添加上装饰器后可以实现:检查文件所在路径(文件)是否存在,如果不存在自动创建文件夹(保证写入文件不报错)  
"""  
import os  
import functools  
  
  
def grad(function):  
    @functools.wraps(function)    def inner(path):        # 获取路径上级目录  
        # folder_path = path.rsplit("/",1)[0]        folder_path = os.path.dirname(path)        # 不存在,就创建  
        if not os.path.exists(folder_path):            os.makedirs(folder_path)        res = function(path)        return res  
    return inner  
  
@grad  
def write_user_info(path):  
    file_obj = open(path, mode="w", encoding="utf-8")    file_obj.write("wupeiqi")    file_obj.close()  
  
write_user_info('./xxx.txt')  
"""
```

```python
# 4. 看代码写结果  
  
def get_data():  
    scores = []  
  
    def inner(val):  
        scores.append(val)  
        print(scores)  
  
    return inner  
  
func = get_data()  
  
func(10)  
func(20)  
func(30)
```
过程：
- 全局作用域中创建函数get data
- 执行func = get data，创建一个get data作用域
- 执行get data函数，创建scores列表，inner函数，return inner的地址
- func变量赋值为inner的内存地址，在scores作用域中
- inner执行的时候传参10，val = 10创建在inner局部作用域中
- 在inner中找scores，没有，在上级中找到一个空列表
- 使用append方法加入到列表中，并在inner作用域中储存，而且因为列表是可变的变量，所以原来的地址被替换了
- 打印scores这个列表 ，在inner局部作用域中就是新的列表有添加10在列表中，这里再inner和get data中都有添加的10
- 同样的另外两个传参是建立两个新的inner作用域，这个时候因为指向的是内存地址，所以scores列表会不断添加值最后变为10 20 30列表

```python
# 5. 看代码写结果  
  
name = "wupeiqi"  
  
def foo():  
    print(name)  
  
def func():  
    name = "root"  
    foo()  
  
func()
```
过程：
- 全局中name = wupeiqi和foo和func函数
- 执行func的时候，作用域中 先有name = root和foo函数
- 执行foo函数，这里是知道foo的内存地址，foo存在全局中
- foo执行print的时候，name全局中找wupeiqi，结果就是wupeiqi


```python
# 6. 看代码写结果  
  
name = "wupeiqi"  
  
def func():  
    name = "root"  
  
    def foo():  
        print(name)  
  
    foo()  
  
func()
```
过程：
- 全局中有name和func储存
- 执行func函数，创建func局部作用域，name = root储存，和foo函数
- 执行foo函数，这时候foo函数上级目录是func作用域
- 所以打印的是name = root，结果就是root

```python
# 7. 看代码写结果  
  
def func(val):  
    def inner(a1, a2):  
        return a1 + a2 + val  
  
    return inner  
  
data_list = []  
  
for i in range(10):  
    data_list.append(func(i))  
  
v1 = data_list[0](11,22)  
v2 = data_list[2](33,11)  
  
print(data_list) # 10个inner函数  
print(v1) # 执行第一个inner函数  
print(v2) # 执行第二个inner函数
```
过程：
就是data list是一个有inner函数地址，引用计数器是10的函数

- 全局作用域中有func函数，data list列表
- 执行for循环，改变data list，执行func函数，并传入参数i，i这里有10个值，不断地覆盖前边一个，但是会储存在10个func函数的局部作用域中，也就是val = 1 2 3 4 ··· 10
- v1 = data list 0个元素，也就是第一个inner，在第一个func作用域中，执行传参11 22 这里func的val = 0，所以结果是 11 + 22 + 0
- 同理v2 在执行的时候 val = 2，已经储存在上级的func作用域中，所以结果是33 + 11 + 2

